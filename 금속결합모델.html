 <!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>금속결합 모델 - 금속 결정의 전자 밀도 시각화</title>
  <style>
    body { text-align: center; font-family: sans-serif; background: #222; color: #fff; }
    .container { display: flex; justify-content: center; gap: 20px; margin-top: 20px; }
    .left-panel { text-align: center; }
    .right-panel { text-align: center; }
    canvas { background: #111; border-radius: 8px; }
    h1 { margin-top: 30px; }
    .desc { margin: 20px auto; max-width: 600px; color: #ccc; min-height: 60px;}
    select, button { font-size: 1.1em; margin: 10px; padding: 4px 10px; }
    label { font-size: 1.1em; }
    .mode-btn { font-weight: bold; border-radius: 6px; border: none; }
    .mode-btn.active { background: #ffeb3b; color: #222; }
    .mode-btn.disabled { 
      opacity: 0.4; 
      filter: grayscale(0.7); 
      cursor: not-allowed; 
      pointer-events: none;
    }
    .action-btn:disabled { opacity: 0.5; }
    #topbar { margin-bottom: 10px; }
    #homeBtn { background: #fff; color: #222; border-radius: 6px; border: none; font-weight: bold; }
    .unit-cell-info { margin-top: 10px; font-size: 0.9em; color: #aaa; }
  </style>
</head>
<body>
  <h1>금속결합 모델</h1>
  <div id="topbar">
    <button id="homeBtn">처음으로</button>
    <button id="modeElectric" class="mode-btn active">전기 전도성</button>
    <button id="modeThermal" class="mode-btn">열 전도성</button>
    <button id="modeDuctility" class="mode-btn">연성과 전성</button>
    <button id="modeLuster" class="mode-btn">광택</button>
  </div>
  <div id="desc" class="desc"></div>
  <label for="elementSelect">금속 원자 선택: </label>
  <select id="elementSelect"></select>
  
  <!-- 전기전도성 모드용 스위치 추가 -->
  <div id="switch-container" style="display: none; margin: 15px 0;">
    <label style="font-size: 1.1em; margin-right: 10px;">전기 스위치:</label>
    <input type="checkbox" id="electric-switch" style="transform: scale(1.5); margin-right: 8px;">
    <span id="switch-status" style="font-weight: bold; color: #ff0000;">OFF</span>
  </div>
  
  <button id="fieldBtn" class="action-btn">전기장 가하기</button>
  <button id="heatBtn" class="action-btn" style="display:none;">열 가하기</button>
  <button id="deformBtn" class="action-btn" style="display:none;">변형 가하기</button>

  
  <!-- 광택 모드용 원자 추가/제거 컨트롤 -->
  <div id="atom-controls" style="display: none; margin: 15px 0;">
    <label style="font-size: 1.1em; margin-right: 10px;">원자 추가/제거:</label>
    <button id="addAtomBtn" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; margin-right: 5px; border-radius: 4px;">원자 추가</button>
    <button id="removeAtomBtn" style="background: #f44336; color: white; border: none; padding: 5px 10px; margin-right: 10px; border-radius: 4px;">원자 제거</button>
    <span id="atomCountDisplay" style="font-weight: bold; color: #ffeb3b;">원자 개수: 0개</span>
    <div style="margin-top: 5px; font-size: 0.9em; color: #ccc;">
      <span style="color: #4CAF50;">●</span> 추가 모드: 격자점을 클릭하여 원자 추가
      <span style="margin-left: 15px; color: #f44336;">●</span> 제거 모드: 원자를 클릭하여 제거
      <div style="margin-top: 3px; color: #999;">※ 원자는 격자점에만 정확히 배치됩니다</div>
    </div>
  </div>
  
  <div class="container">
    <div class="left-panel">
      <h3 id="leftTitle">전자 밀도 분포</h3>
      <canvas id="densityCanvas" width="400" height="400"></canvas>
      <div style="margin-top: 10px; font-size: 0.8em; color: #888; font-style: italic;">
        ignorance: 격자 구조에 따른 원자의 배열은 고려하지 않음.
      </div>
    </div>
    <div class="right-panel">
      <h3 id="rightTitle">단위세포 구조</h3>
      <canvas id="unitCellCanvas" width="400" height="400"></canvas>
      <div id="unitCellInfo" class="unit-cell-info"></div>
    </div>
  </div>
  
  <!-- 광택 모드용 스펙트럼 캔버스 -->
  <div id="spectrum-container" style="display: none; margin-top: 20px;">
    <h3>스펙트럼 분석</h3>
    <canvas id="spectrumCanvas" width="800" height="200"></canvas>
  </div>

  <!-- 금속결합 이론 설명 (광택 모드에서만 표시) -->
  <div id="theory-container" style="display: none; margin-top: 30px; padding: 20px; background: linear-gradient(135deg, #1a1a2e, #16213e); border-radius: 15px; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
    <div style="max-width: 1200px; margin: 0 auto;">
      
      <!-- 선 스펙트럼 섹션 -->
      <div style="margin-bottom: 30px; padding: 25px; background: rgba(255,255,255,0.05); border-radius: 12px; border-left: 4px solid #4CAF50;">
        <h3 style="color: #4CAF50; margin: 0 0 15px 0; font-size: 1.4em; display: flex; align-items: center;">
          <span style="background: #4CAF50; color: white; padding: 8px 12px; border-radius: 50%; margin-right: 12px; font-size: 0.8em;">1</span>
          선 스펙트럼
        </h3>
        <p style="color: #e0e0e0; line-height: 1.8; font-size: 1.1em; margin: 0;">
          원자는 들어온 에너지를 흡수하고 주변에 그 에너지를 다시 방출할 수 있습니다. 단원자 분자나 금속 기체와 같은 단일 원자가 방출하는 에너지는 정해진 값만 가질 수 있습니다. 이것은 원자핵에 종속된 전자들이 띄엄띄엄하게 정해진 에너지만 가질 수 있기 때문입니다.
        </p>
      </div>

      <!-- 연속 스펙트럼 섹션 -->
      <div style="margin-bottom: 30px; padding: 25px; background: rgba(255,255,255,0.05); border-radius: 12px; border-left: 4px solid #2196F3;">
        <h3 style="color: #2196F3; margin: 0 0 15px 0; font-size: 1.4em; display: flex; align-items: center;">
          <span style="background: #2196F3; color: white; padding: 8px 12px; border-radius: 50%; margin-right: 12px; font-size: 0.8em;">2</span>
          연속 스펙트럼
        </h3>
        <p style="color: #e0e0e0; line-height: 1.8; font-size: 1.1em; margin: 0;">
          원자핵이 하나만 홀로 있다면 위와 같이 설명하고 끝이 나겠지만, 고체와 같이 원자핵들이 밀도 있게 붙어 있는 경우에는 원자들이 가진 전자 궤도들이 서로 포개지면서 두꺼워집니다.
        </p>
        <p style="color: #e0e0e0; line-height: 1.8; font-size: 1.1em; margin: 15px 0 0 0;">
          그 결과 에너지 준위는 이제 하나의 선이 아니라 일정한 폭을 가진 띠(밴드)의 형태를 띠게 됩니다. 이렇게 두껍게 된 에너지 준위를 <strong style="color: #2196F3;">에너지 띠(energy band)</strong>라고 부르며, 띠와 띠 사이, 선과 띠 사이에서는 해당 에너지를 가지는 전자들이 존재할 수 없기 때문에 <strong style="color: #2196F3;">띠 간격(energy gap)</strong>이라고 부릅니다.
        </p>
        <p style="color: #e0e0e0; line-height: 1.8; font-size: 1.1em; margin: 15px 0 0 0;">
          띠(밴드)가 형성되면 방출되는 에너지도 다양해지며, 일부 연속된 스펙트럼이 관찰되기 시작합니다.
        </p>
      </div>

      <!-- 금속의 은색 섹션 -->
      <div style="margin-bottom: 30px; padding: 25px; background: rgba(255,255,255,0.05); border-radius: 12px; border-left: 4px solid #FF9800;">
        <h3 style="color: #FF9800; margin: 0 0 15px 0; font-size: 1.4em; display: flex; align-items: center;">
          <span style="background: #FF9800; color: white; padding: 8px 12px; border-radius: 50%; margin-right: 12px; font-size: 0.8em;">3</span>
          실온의 고체 금속이 대부분 은색을 띠는 이유
        </h3>
        <p style="color: #e0e0e0; line-height: 1.8; font-size: 1.1em; margin: 0;">
          대부분의 금속은 원자 구조 외곽에 대규모의 전자 띠를 가지고 있습니다(금속 결합). 그리고 자유 전자들이 띠에서 자유롭게 움직일 수 있습니다. 이 때문에 금속은 대부분의 가시광선 파장을 흡수할 수 있고, 그대로 다시 방출할 수 있습니다.
        </p>
      </div>

      <!-- ignorance -->
      <div style="padding: 20px; background: rgba(255,193,7,0.1); border-radius: 12px; border-left: 4px solid #FFC107;">
        <h4 style="color: #FFC107; margin: 0 0 10px 0; font-size: 1.2em; display: flex; align-items: center;">
          <span style="background: #FFC107; color: #333; padding: 6px 10px; border-radius: 50%; margin-right: 10px; font-size: 0.7em;">!</span>
          ignorance
        </h4>
        <p style="color: #e0e0e0; line-height: 1.6; font-size: 1em; margin: 0; font-style: italic;">
          나타난 스펙트럼이 실제 원소의 스펙트럼을 나타내지는 않음. 표면 플라즈몬 공명이 무시되어 있음.
        </p>
      </div>

    </div>
  </div>

  <script>
    // 금속 원자 데이터에 격자 구조 정보 추가 (방출 스펙트럼 글자색 기반)
    const elements = [
      { 
        symbol: "Na", name: "나트륨", radius: 186, ionRadius: 102, valence: 1, color: "#FFD122",
        lattice: "BCC", unitCell: { a: 429 }, description: "체심입방격자 (Body-Centered Cubic)",
        emissionLines: [
          { wavelength: 589.0, intensity: 1.0, color: "#FFD122" }, // 주요 노란색 선
          { wavelength: 589.6, intensity: 0.8, color: "#FFD122" }  // 보조 노란색 선
        ]
      },
      { 
        symbol: "Cu", name: "구리", radius: 128, ionRadius: 77, valence: 1, color: "#A8FFFF",
        lattice: "FCC", unitCell: { a: 361 }, description: "면심입방격자 (Face-Centered Cubic)",
        emissionLines: [
          { wavelength: 510.6, intensity: 1.0, color: "#00FF00" }, // 주요 녹색 선
          { wavelength: 515.3, intensity: 0.7, color: "#00FF00" }, // 보조 녹색 선
          { wavelength: 521.8, intensity: 0.5, color: "#00FFFF" }  // 청녹색 선
        ]
      },
      { 
        symbol: "Ag", name: "은", radius: 144, ionRadius: 115, valence: 1, color: "#59FFA0",
        lattice: "FCC", unitCell: { a: 409 }, description: "면심입방격자 (Face-Centered Cubic)",
        emissionLines: [
          { wavelength: 520.9, intensity: 1.0, color: "#59FFA0" }, // 주요 녹색 선
          { wavelength: 546.5, intensity: 0.8, color: "#59FFA0" }, // 보조 녹색 선
          { wavelength: 328.1, intensity: 0.6, color: "#8080FF" }  // 자외선 (가시광선으로 변환)
        ]
      },
      { 
        symbol: "Au", name: "금", radius: 144, ionRadius: 137, valence: 1, color: "#CFD8FF",
        lattice: "FCC", unitCell: { a: 408 }, description: "면심입방격자 (Face-Centered Cubic)",
        emissionLines: [
          { wavelength: 479.3, intensity: 1.0, color: "#CFD8FF" }, // 주요 청색 선
          { wavelength: 627.8, intensity: 0.9, color: "#FFA500" }, // 주황색 선
          { wavelength: 583.2, intensity: 0.6, color: "#FFD700" }  // 황금색 선
        ]
      },
      { 
        symbol: "Fe", name: "철", radius: 126, ionRadius: 78, valence: 2, color: "#52D9FF",
        lattice: "BCC", unitCell: { a: 287 }, description: "체심입방격자 (Body-Centered Cubic)",
        emissionLines: [
          { wavelength: 404.6, intensity: 1.0, color: "#8000FF" }, // 주요 보라색 선
          { wavelength: 438.4, intensity: 0.8, color: "#0080FF" }, // 청색 선
          { wavelength: 495.8, intensity: 0.7, color: "#00FFFF" }, // 청녹색 선
          { wavelength: 526.9, intensity: 0.6, color: "#00FF00" }  // 녹색 선
        ]
      },
      { 
        symbol: "Al", name: "알루미늄", radius: 143, ionRadius: 53.5, valence: 3, color: "#80E0FF",
        lattice: "FCC", unitCell: { a: 405 }, description: "면심입방격자 (Face-Centered Cubic)",
        emissionLines: [
          { wavelength: 396.2, intensity: 1.0, color: "#8000FF" }, // 주요 보라색 선
          { wavelength: 394.4, intensity: 0.8, color: "#8000FF" }, // 보조 보라색 선
          { wavelength: 308.2, intensity: 0.5, color: "#400080" }  // 자외선 (가시광선으로 변환)
        ]
      }
    ];

    // UI 요소들
    const select = document.getElementById('elementSelect');
    const fieldBtn = document.getElementById('fieldBtn');
    const heatBtn = document.getElementById('heatBtn');
    const modeElectric = document.getElementById('modeElectric');
    const modeThermal = document.getElementById('modeThermal');
    const modeDuctility = document.getElementById('modeDuctility');
    const modeLuster = document.getElementById('modeLuster');
    const homeBtn = document.getElementById('homeBtn');
    const desc = document.getElementById('desc');
    const unitCellInfo = document.getElementById('unitCellInfo');
    const spectrumContainer = document.getElementById('spectrum-container');
    const spectrumCanvas = document.getElementById('spectrumCanvas');
    const spectrumType = document.getElementById('spectrumType');
    const spectrumInfo = document.getElementById('spectrumInfo');
    const leftTitle = document.getElementById('leftTitle');
    const rightTitle = document.getElementById('rightTitle');
    const atomControls = document.getElementById('atom-controls');
    const addAtomBtn = document.getElementById('addAtomBtn');
    const removeAtomBtn = document.getElementById('removeAtomBtn');
    const atomCountDisplay = document.getElementById('atomCountDisplay');
    const switchContainer = document.getElementById('switch-container');
    const electricSwitch = document.getElementById('electric-switch');
    const switchStatus = document.getElementById('switch-status');
    const deformBtn = document.getElementById('deformBtn');
    
    // 캔버스들
    const densityCanvas = document.getElementById('densityCanvas');
    const unitCellCanvas = document.getElementById('unitCellCanvas');
    const densityCtx = densityCanvas.getContext('2d');
    const unitCellCtx = unitCellCanvas.getContext('2d');

    // 3D 단위세포 관련 변수
    let rotationX = 0, rotationY = 0;
    let isDragging = false;
    let lastMouseX = 0, lastMouseY = 0;

    // UI 초기화
    elements.forEach((el, i) => {
      const option = document.createElement('option');
      option.value = i;
      option.textContent = `${el.symbol} (${el.name})`;
      select.appendChild(option);
    });

    // 캔버스 및 격자 설정
    const canvas = document.getElementById('densityCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    const gridSize = 5; // 5x5 격자
    const spacing = width / (gridSize + 1);

    // 변환 함수들
    function radiusToSigma(radius_pm) {
      const minR = 120, maxR = 190;
      const minS = spacing * 0.33, maxS = spacing * 0.5;
      return minS + (radius_pm - minR) / (maxR - minR) * (maxS - minS);
    }
    function radiusToPixel(radius_pm) {
      const minR = 120, maxR = 190;
      const minP = spacing * 0.34, maxP = spacing * 0.5;
      return minP + (radius_pm - minR) / (maxR - minR) * (maxP - minP);
    }
    function ionRadiusToPixel(ionRadius_pm) {
      const minR = 50, maxR = 140;
      const minP = spacing * 0.15, maxP = spacing * 0.37;
      return minP + (ionRadius_pm - minR) / (maxR - minR) * (maxP - minP);
    }

    // 배경 캐싱을 위한 오프스크린 캔버스
    const backgroundCanvas = document.createElement('canvas');
    const backgroundCtx = backgroundCanvas.getContext('2d');
    backgroundCanvas.width = densityCanvas.width;
    backgroundCanvas.height = densityCanvas.height;
    
    // 캐시 무효화 플래그들
    let cacheInvalid = true;
    let lastElement = null;
    let lastMode = null;
    let lastDeformOffset = 0;
    let currentElement = elements[0];
    let currentGridSize = 5;
    
    // 상태 변수
    let mode = "electric"; // "electric" or "thermal" or "home"
    let fieldActive = false, fieldOffset = 0;
    let heatActive = false, heatFront = 0;
    let animating = false;
    let animationFrame = null;
    
    // 전자 시뮬레이션 관련 변수
    let electrons = [];
    let switchOn = false;
    let electronAnimationId = null;
    
    // 연성과 전성 모드용 변수
    let deformActive = false;
    let deformOffset = 0;
    
    // 광택 모드용 변수
    let spectrumActive = false;
    let isSolidState = false;
    
    // 원자 추가/제거 기능용 변수
    let customAtoms = []; // 사용자가 추가한 원자들
    let atomCount = 0; // 현재 원자 개수
    let isAddingMode = true; // true: 추가 모드, false: 제거 모드
    
    // 열전도성 관련 변수
    let thermalElectrons = [];
    let heatAnimationId = null;
    let hotSourceVisible = false;
    let hotSourceContact = false;
    let atomTemperatures = new Map(); // 각 원자의 온도 저장
    let atomCollisionCounts = new Map(); // 각 원자의 충돌 횟수 저장

         // 전자 클래스 정의
     class Electron {
       constructor(x, y) {
         this.x = x;
         this.y = y;
         this.vx = (Math.random() - 0.5) * 3; // 초기 속도 감소
         this.vy = (Math.random() - 0.5) * 3;
         this.radius = 4;
         this.color = "#ffffff";
       }
       
       update(atoms, switchOn) {
         // 전기장 효과 (스위치가 켜져있을 때)
         if (switchOn) {
           this.vx += 0.6; // 오른쪽으로 가속 감소
         }
         
         // 속도 제한 감소
         const maxSpeed = 6; // 최대 속도 감소
         this.vx = Math.max(-maxSpeed, Math.min(maxSpeed, this.vx));
         this.vy = Math.max(-maxSpeed, Math.min(maxSpeed, this.vy));
         
         // 위치 업데이트 (더 빠른 움직임)
         this.x += this.vx;
         this.y += this.vy;
         
         // 경계 처리 - 전기전도성 모드에서 연속적인 전류 흐름
         if (switchOn) {
           // 오른쪽 끝에서 사라지면 왼쪽에서 다시 나타남
           if (this.x > densityCanvas.width + 10) {
             this.x = -10;
             this.y = Math.random() * densityCanvas.height;
             this.vx = (Math.random() - 0.5) * 2 + 1; // 오른쪽 방향으로 초기 속도 감소
             this.vy = (Math.random() - 0.5) * 2;
           }
           // 왼쪽 끝에서 사라지면 오른쪽에서 다시 나타남 (역방향 전류 방지)
           if (this.x < -10) {
             this.x = densityCanvas.width + 10;
             this.y = Math.random() * densityCanvas.height;
             this.vx = (Math.random() - 0.5) * 2 + 1; // 오른쪽 방향으로 초기 속도 감소
             this.vy = (Math.random() - 0.5) * 2;
           }
         } else {
           // 스위치가 꺼져있을 때는 기존 경계 처리
           if (this.x < 0 || this.x > densityCanvas.width) {
             this.vx *= -0.9; // 벽에 부딪히면 반사 (에너지 손실 감소)
             this.x = Math.max(0, Math.min(densityCanvas.width, this.x));
           }
         }
         
         // 세로 경계 처리 (항상 반사)
         if (this.y < 0 || this.y > densityCanvas.height) {
           this.vy *= -0.9; // 벽에 부딪히면 반사 (에너지 손실 감소)
           this.y = Math.max(0, Math.min(densityCanvas.height, this.y));
         }
         
         // 원자핵과의 충돌 처리
         for (let i = 0; i < atoms.length; i++) {
           const [cx, cy] = atoms[i];
           const dx = this.x - cx;
           const dy = this.y - cy;
           const distance = Math.sqrt(dx * dx + dy * dy);
           const collisionRadius = 18; // 충돌 반경 약간 감소
           
           if (distance < collisionRadius) {
             // 충돌 시 반사
             const angle = Math.atan2(dy, dx);
             const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
             
             // 반사각 계산 (에너지 손실 감소)
             this.vx = speed * Math.cos(angle) * 0.9;
             this.vy = speed * Math.sin(angle) * 0.9;
             
             // 최소 속도 보장 (충돌 후에도)
             const minSpeed = 1.5;
             const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
             if (currentSpeed < minSpeed) {
               const speedRatio = minSpeed / currentSpeed;
               this.vx *= speedRatio;
               this.vy *= speedRatio;
             }
             
             // 원자핵 밖으로 밀어내기
             this.x = cx + Math.cos(angle) * collisionRadius;
             this.y = cy + Math.sin(angle) * collisionRadius;
             
             // 양방향 열 전달 시스템
             const atomTemperature = atomTemperatures.get(i) || 0;
             const tempDifference = Math.abs(this.temperature - atomTemperature);
             
             if (tempDifference > 10) { // 온도 차이가 10도 이상일 때만 열 전달
               if (this.temperature > atomTemperature + 10) {
                 // 전자가 원자보다 뜨거우면: 전자 → 원자 열 전달
                 const heatTransfer = Math.min(15, tempDifference * 0.6); // 열 전달량 증가
                 
                 // 원자 온도 증가
                 atomTemperatures.set(i, Math.min(atomTemperature + heatTransfer, 200));
                 
                 // 충돌 횟수 증가
                 const currentCollisions = atomCollisionCounts.get(i) || 0;
                 atomCollisionCounts.set(i, currentCollisions + 1);
                 
                 // 전자 에너지 감소
                 this.temperature = Math.max(10, this.temperature - heatTransfer * 0.4); // 에너지 손실 증가
                 
               } else if (atomTemperature > this.temperature + 10) {
                 // 원자가 전자보다 뜨거우면: 원자 → 전자 열 전달
                 const heatTransfer = Math.min(12, tempDifference * 0.4); // 열 전달량 증가
                 
                 // 전자 온도 증가
                 this.temperature = Math.min(this.temperature + heatTransfer, 200);
                 
                 // 원자 온도 감소 (열원 근처 원자는 제외)
                 if (!isHeaterAtom(i)) {
                   atomTemperatures.set(i, Math.max(10, atomTemperature - heatTransfer * 0.2)); // 원자 온도 감소 증가
                 }
               }
               
               // 속도 조정 (에너지 변화에 따라)
               const speedAdjustment = 1 + (this.temperature - 50) / 200;
               this.vx *= speedAdjustment;
               this.vy *= speedAdjustment;
               
               // 최소 속도 보장 (속도 조정 후에도)
               const minSpeed = 1.5;
               const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
               if (currentSpeed < minSpeed) {
                 const speedRatio = minSpeed / currentSpeed;
                 this.vx *= speedRatio;
                 this.vy *= speedRatio;
               }
             }
             break; // 첫 번째 충돌만 처리 (성능 최적화)
           }
         }
       }
      
      draw(ctx) {
        // 전자 외곽선 (검은색)
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        ctx.stroke();
        
        // 전자 내부 (흰색)
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
        ctx.fill();
        
        // 전자 궤적 (스위치가 켜져있을 때)
        if (switchOn) {
          ctx.strokeStyle = "#00ffff";
          ctx.lineWidth = 3;
          ctx.globalAlpha = 0.6;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y);
          ctx.lineTo(this.x - this.vx * 3, this.y - this.vy * 3);
          ctx.stroke();
          
          // 추가 궤적 효과
          ctx.lineWidth = 2;
          ctx.globalAlpha = 0.3;
          ctx.beginPath();
          ctx.moveTo(this.x - this.vx * 3, this.y - this.vy * 3);
          ctx.lineTo(this.x - this.vx * 6, this.y - this.vy * 6);
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        }
      }
    }

     // 열전도성용 전자 클래스 정의
     class ThermalElectron {
       constructor(x, y) {
         this.x = x;
         this.y = y;
         this.vx = (Math.random() - 0.5) * 4;
         this.vy = (Math.random() - 0.5) * 4;
         this.radius = 4;
         this.color = "#ffffff";
         this.temperature = 0; // 전자의 온도
         this.isHot = false; // 고온 열원과 접촉했는지 여부
       }
       
       update(atoms) {
         // 고온 열원과 접촉 시 자유롭고 무작위한 움직임
         if (this.isHot) {
           this.temperature = Math.max(this.temperature, 150); // 더 높은 온도로 설정
           // 무작위한 방향으로 움직임 (한쪽 방향 제거)
           this.vx += (Math.random() - 0.5) * 1.2; // 더 활발한 움직임
           this.vy += (Math.random() - 0.5) * 1.2;
         }
         
         // 속도 제한 (고온 전자는 더 빠르게)
         const maxSpeed = this.isHot ? 10 : 6;
         const minSpeed = 1.5; // 최소 속도 설정
         
         this.vx = Math.max(-maxSpeed, Math.min(maxSpeed, this.vx));
         this.vy = Math.max(-maxSpeed, Math.min(maxSpeed, this.vy));
         
         // 최소 속도 보장
         const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
         if (currentSpeed < minSpeed) {
           const speedRatio = minSpeed / currentSpeed;
           this.vx *= speedRatio;
           this.vy *= speedRatio;
         }
         
         // 위치 업데이트
         this.x += this.vx;
         this.y += this.vy;
         
         // 경계 처리
         if (this.x < 0 || this.x > densityCanvas.width) {
           this.vx *= -0.8;
           this.x = Math.max(0, Math.min(densityCanvas.width, this.x));
         }
         if (this.y < 0 || this.y > densityCanvas.height) {
           this.vy *= -0.8;
           this.y = Math.max(0, Math.min(densityCanvas.height, this.y));
         }
         
         // 원자핵과의 충돌 처리 및 열 전달 (최적화)
         const collisionRadius = 18;
         const collisionRadiusSq = collisionRadius * collisionRadius;
         
         // 가까운 원자들만 검사 (성능 최적화)
         for (let i = 0; i < atoms.length; i++) {
           const [cx, cy] = atoms[i];
           const dx = this.x - cx;
           const dy = this.y - cy;
           const distanceSq = dx * dx + dy * dy; // 제곱 거리 사용 (sqrt 제거)
           
           if (distanceSq < collisionRadiusSq) {
             // 충돌 시 반사
             const distance = Math.sqrt(distanceSq);
             const angle = Math.atan2(dy, dx);
             const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
             
             this.vx = speed * Math.cos(angle) * 0.8;
             this.vy = speed * Math.sin(angle) * 0.8;
             
             // 최소 속도 보장 (충돌 후에도)
             const minSpeed = 1.5;
             const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
             if (currentSpeed < minSpeed) {
               const speedRatio = minSpeed / currentSpeed;
               this.vx *= speedRatio;
               this.vy *= speedRatio;
             }
             
             // 원자핵 밖으로 밀어내기
             this.x = cx + Math.cos(angle) * collisionRadius;
             this.y = cy + Math.sin(angle) * collisionRadius;
             
             // 양방향 열 전달 시스템
             const atomTemperature = atomTemperatures.get(i) || 0;
             const tempDifference = Math.abs(this.temperature - atomTemperature);
             
             if (tempDifference > 10) { // 온도 차이가 10도 이상일 때만 열 전달
               if (this.temperature > atomTemperature + 10) {
                 // 전자가 원자보다 뜨거우면: 전자 → 원자 열 전달
                 const heatTransfer = Math.min(15, tempDifference * 0.6); // 열 전달량 증가
                 
                 // 원자 온도 증가
                 atomTemperatures.set(i, Math.min(atomTemperature + heatTransfer, 200));
                 
                 // 충돌 횟수 증가
                 const currentCollisions = atomCollisionCounts.get(i) || 0;
                 atomCollisionCounts.set(i, currentCollisions + 1);
                 
                 // 전자 에너지 감소
                 this.temperature = Math.max(10, this.temperature - heatTransfer * 0.4); // 에너지 손실 증가
                 
               } else if (atomTemperature > this.temperature + 10) {
                 // 원자가 전자보다 뜨거우면: 원자 → 전자 열 전달
                 const heatTransfer = Math.min(12, tempDifference * 0.4); // 열 전달량 증가
                 
                 // 전자 온도 증가
                 this.temperature = Math.min(this.temperature + heatTransfer, 200);
                 
                 // 원자 온도 감소 (열원 근처 원자는 제외)
                 if (!isHeaterAtom(i)) {
                   atomTemperatures.set(i, Math.max(10, atomTemperature - heatTransfer * 0.2)); // 원자 온도 감소 증가
                 }
               }
               
               // 속도 조정 (에너지 변화에 따라)
               const speedAdjustment = 1 + (this.temperature - 50) / 200;
               this.vx *= speedAdjustment;
               this.vy *= speedAdjustment;
               
               // 최소 속도 보장 (속도 조정 후에도)
               const minSpeed = 1.5;
               const currentSpeed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
               if (currentSpeed < minSpeed) {
                 const speedRatio = minSpeed / currentSpeed;
                 this.vx *= speedRatio;
                 this.vy *= speedRatio;
               }
             }
             break; // 첫 번째 충돌만 처리 (성능 최적화)
           }
         }
         
         // 온도 감쇠 (더 느리게)
         this.temperature *= 0.998;
       }
       
       draw(ctx) {
         // 온도에 따른 색상 변화 (R값 고정, G,B 점차 감소)
         const r = 255; // R값 고정
         let g, b;
         
         if (this.temperature > 150) {
           // 150~200도: 진한 붉은색
           const t = Math.min((this.temperature - 150) / 50, 1);
           g = Math.round(50 * (1 - t)); // 50 → 0
           b = Math.round(50 * (1 - t)); // 50 → 0
         } else if (this.temperature > 100) {
           // 100~150도: 붉은색
           const t = (this.temperature - 100) / 50;
           g = Math.round(100 * (1 - t) + 50 * t); // 100 → 50
           b = Math.round(100 * (1 - t) + 50 * t); // 100 → 50
         } else if (this.temperature > 60) {
           // 60~100도: 분홍색
           const t = (this.temperature - 60) / 40;
           g = Math.round(150 * (1 - t) + 100 * t); // 150 → 100
           b = Math.round(150 * (1 - t) + 100 * t); // 150 → 100
         } else if (this.temperature > 30) {
           // 30~60도: 연분홍색
           const t = (this.temperature - 30) / 30;
           g = Math.round(200 * (1 - t) + 150 * t); // 200 → 150
           b = Math.round(200 * (1 - t) + 150 * t); // 200 → 150
         } else if (this.temperature > 10) {
           // 10~30도: 연한 분홍색
           const t = (this.temperature - 10) / 20;
           g = Math.round(240 * (1 - t) + 200 * t); // 240 → 200
           b = Math.round(240 * (1 - t) + 200 * t); // 240 → 200
         } else {
           // 0~10도: 흰색
           g = 255;
           b = 255;
         }
         
         this.color = `rgb(${r},${g},${b})`;
         
         // 전자 외곽선 (검은색)
         ctx.strokeStyle = "#000000";
         ctx.lineWidth = 2;
         ctx.beginPath();
         ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
         ctx.stroke();
         
         // 전자 내부
         ctx.fillStyle = this.color;
         ctx.beginPath();
         ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
         ctx.fill();
         
         // 고온 전자의 궤적 (온도에 따라 궤적 길이 변화)
         if (this.temperature > 30) {
           const trailLength = Math.min(this.temperature / 50, 2); // 온도에 따른 궤적 길이
           ctx.strokeStyle = this.color;
           ctx.lineWidth = 3;
           ctx.globalAlpha = 0.7 * (this.temperature / 200); // 온도에 따른 투명도
           ctx.beginPath();
           ctx.moveTo(this.x, this.y);
           ctx.lineTo(this.x - this.vx * 4 * trailLength, this.y - this.vy * 4 * trailLength);
           ctx.stroke();
           
           // 추가 궤적 효과
           ctx.lineWidth = 2;
           ctx.globalAlpha = 0.4 * (this.temperature / 200);
           ctx.beginPath();
           ctx.moveTo(this.x - this.vx * 4 * trailLength, this.y - this.vy * 4 * trailLength);
           ctx.lineTo(this.x - this.vx * 8 * trailLength, this.y - this.vy * 8 * trailLength);
           ctx.stroke();
           ctx.globalAlpha = 1.0;
         }
       }
     }

     // 전자 시뮬레이션 초기화
     function initElectrons() {
       electrons = [];
       const numElectrons = 40; // 전자 수 증가
       
       for (let i = 0; i < numElectrons; i++) {
         const x = Math.random() * densityCanvas.width;
         const y = Math.random() * densityCanvas.height;
         electrons.push(new Electron(x, y));
       }
     }

     // 열전도성용 전자들 초기화
     function initThermalElectrons() {
       thermalElectrons = [];
       // 온도는 초기화하지 않음 (붉은 상태 유지)
       const numElectrons = 50; // 전자 개수 증가 (더 많은 충돌)
       
       for (let i = 0; i < numElectrons; i++) {
         const x = Math.random() * densityCanvas.width;
         const y = Math.random() * densityCanvas.height;
         thermalElectrons.push(new ThermalElectron(x, y));
       }
     }

         // 전자 시뮬레이션 애니메이션
     function animateElectrons() {
       const ctx = densityCtx;
       const element = elements[select.value];
       
       // 격자점 좌표 계산 (6x6 격자로 전체 캔버스에 배치)
       const atoms = [];
       const margin = spacing / 2;
       const currentGridSize = 6; // 전기전도성 모드: 6x6
       for (let i = 0; i <= Math.floor(densityCanvas.width / spacing); i++) {
         for (let j = 0; j <= Math.floor(densityCanvas.height / spacing); j++) {
           const x = i * spacing + margin;
           const y = j * spacing + margin;
           if (x < densityCanvas.width && y < densityCanvas.height) {
             atoms.push([x, y]);
           }
         }
       }
       
       // 배경 지우기
       ctx.clearRect(0, 0, densityCanvas.width, densityCanvas.height);
       
       // 전자밀도 그리기 (반투명)
       drawDensity(element, fieldOffset, fieldActive, heatFront, heatActive);
       ctx.globalAlpha = 0.3;
       
       // 전자들 업데이트 및 그리기
       electrons.forEach(electron => {
         electron.update(atoms, switchOn);
         electron.draw(ctx);
       });
       
       // 전자 순환 시스템: 전자 수 유지
       if (switchOn && electrons.length < 45) {
         // 왼쪽에서 새로운 전자 추가
         electrons.push(new Electron(-20, Math.random() * densityCanvas.height));
       }
       
       ctx.globalAlpha = 1.0;
       
       // 격자점(양이온) 그리기
       ctx.strokeStyle = "#fff";
       ctx.lineWidth = 2;
       ctx.font = "14px sans-serif";
       ctx.textAlign = "center";
       ctx.textBaseline = "top";
       ctx.fillStyle = "#fff";
       
       for (const [cx, cy] of atoms) {
         const atomRadiusPx = radiusToPixel(element.radius);
         const ionRadiusPx = ionRadiusToPixel(element.ionRadius);
         
         // 원자 반지름 원
         ctx.save();
         ctx.globalAlpha = 0.5;
         ctx.beginPath();
         ctx.arc(cx, cy, atomRadiusPx, 0, 2 * Math.PI);
         ctx.strokeStyle = "#fff";
         ctx.lineWidth = 1.2;
         ctx.stroke();
         ctx.restore();
         
         // 금속양이온
         ctx.beginPath();
         ctx.arc(cx, cy, ionRadiusPx, 0, 2 * Math.PI);
         ctx.fillStyle = "#fff";
         ctx.globalAlpha = 0.85;
         ctx.fill();
         ctx.globalAlpha = 1.0;
         ctx.strokeStyle = "#888";
         ctx.lineWidth = 1;
         ctx.stroke();
       }
       
       // 전기장 방향 표시 (스위치가 켜져있을 때)
       if (switchOn) {
         ctx.save();
         // 전기장 화살표 (오른쪽 방향)
         ctx.strokeStyle = "#ffeb3b";
         ctx.fillStyle = "#ffeb3b";
         ctx.lineWidth = 4;
         
         // 화살표 몸통
         ctx.beginPath();
         ctx.moveTo(densityCanvas.width - 150, 50);
         ctx.lineTo(densityCanvas.width - 50, 50);
         ctx.stroke();
         
         // 화살촉
         ctx.beginPath();
         ctx.moveTo(densityCanvas.width - 50, 50);
         ctx.lineTo(densityCanvas.width - 70, 40);
         ctx.lineTo(densityCanvas.width - 70, 60);
         ctx.closePath();
         ctx.fill();
         
         // 전기장 텍스트
         ctx.font = "bold 24px sans-serif"; // 글자 크기 증가
         ctx.textAlign = "center";
         ctx.fillStyle = "#ffeb3b";
         // 외곽선 추가로 가시성 향상
         ctx.strokeStyle = "#000000";
         ctx.lineWidth = 3;
         ctx.strokeText("전기장 E", densityCanvas.width - 100, 80);
         ctx.fillText("전기장 E", densityCanvas.width - 100, 80);
         
         // 전류 방향 표시 (전자 흐름)
         ctx.strokeStyle = "#00ffff";
         ctx.lineWidth = 2;
         ctx.setLineDash([5, 5]);
         ctx.beginPath();
         ctx.moveTo(50, densityCanvas.height - 50);
         ctx.lineTo(densityCanvas.width - 50, densityCanvas.height - 50);
         ctx.stroke();
         ctx.setLineDash([]);
         
         ctx.font = "bold 16px sans-serif";
         ctx.fillStyle = "#00ffff";
         ctx.fillText("전자 흐름", densityCanvas.width / 2, densityCanvas.height - 70);
         
         ctx.restore();
       }
       
       electronAnimationId = requestAnimationFrame(animateElectrons);
     }

     // 열전도성 애니메이션
     function animateHeatConduction() {
       const ctx = densityCtx;
       const element = elements[select.value];
       const time = Date.now() * 0.001;
       
       // 격자점 좌표 계산 (6x6 격자로 전체 캔버스에 배치)
       const atoms = [];
       const margin = spacing / 2;
       const currentGridSize = 6; // 열전도성 모드: 6x6
       for (let i = 0; i <= Math.floor(densityCanvas.width / spacing); i++) {
         for (let j = 0; j <= Math.floor(densityCanvas.height / spacing); j++) {
           const x = i * spacing + margin;
           const y = j * spacing + margin;
           if (x < densityCanvas.width && y < densityCanvas.height) {
             atoms.push([x, y]);
           }
         }
       }
       
       // 배경 지우기
       ctx.clearRect(0, 0, densityCanvas.width, densityCanvas.height);
       
       // 전자밀도 그리기 (반투명)
       drawDensity(element, fieldOffset, fieldActive, heatFront, heatActive);
       ctx.globalAlpha = 0.3;
       
       // 고온 열원 그리기 (맨 왼쪽 줄의 6개 원자)
       if (hotSourceVisible) {
         ctx.save();
         
         // 맨 왼쪽 줄의 6개 원자 위치에 열원 표시
         const spacing = densityCanvas.width / 7;
         const margin = spacing / 2;
         const leftColumnX = margin;
         
         // 열원 영역 표시 (맨 왼쪽 줄 전체)
         const heaterWidth = 40;
         const heaterHeight = densityCanvas.height - 40;
         const heaterX = leftColumnX - heaterWidth/2;
         const heaterY = 20;
         
         // 그림자 효과
         ctx.shadowColor = 'rgba(255, 0, 0, 0.3)';
         ctx.shadowBlur = 20;
         ctx.shadowOffsetX = 3;
         ctx.shadowOffsetY = 3;
         
         // 열원 영역 외곽선
         ctx.strokeStyle = "#ff0000";
         ctx.lineWidth = 3;
         ctx.setLineDash([8, 4]);
         ctx.beginPath();
         ctx.rect(heaterX, heaterY, heaterWidth, heaterHeight);
         ctx.stroke();
         ctx.setLineDash([]);
         
         // 열원 영역 내부 (반투명)
         ctx.fillStyle = "rgba(255, 0, 0, 0.1)";
         ctx.beginPath();
         ctx.rect(heaterX, heaterY, heaterWidth, heaterHeight);
         ctx.fill();
         
         // 그림자 효과 제거
         ctx.shadowColor = 'transparent';
         ctx.shadowBlur = 0;
         ctx.shadowOffsetX = 0;
         ctx.shadowOffsetY = 0;
         
         // 열원 라벨
         ctx.font = "bold 16px sans-serif";
         ctx.fillStyle = "#ff0000";
         ctx.textAlign = "center";
         ctx.fillText("고온 열원", heaterX + heaterWidth/2, heaterY - 15);
         
         // 온도 표시
         ctx.font = "bold 14px sans-serif";
         ctx.fillStyle = "#ff0000";
         ctx.fillText("800°C", heaterX + heaterWidth/2, heaterY + heaterHeight + 25);
         
         // 열기 효과 (파티클) - 맨 왼쪽 줄에서 오른쪽으로
         for (let i = 0; i < 15; i++) {
           const x = heaterX + heaterWidth + 5 + Math.random() * 30;
           const y = heaterY + 20 + (i * (heaterHeight - 40) / 14);
           const alpha = 0.3 + 0.4 * Math.sin(time * 3 + i);
           const size = 1.5 + Math.sin(time * 2 + i) * 1;
           
           ctx.fillStyle = `rgba(255, 100, 0, ${alpha})`;
           ctx.beginPath();
           ctx.arc(x, y, size, 0, 2 * Math.PI);
           ctx.fill();
         }
         
         // 접촉 상태에 따른 표시
         if (hotSourceContact) {
           // 접촉 시: 열원 영역 강조
           ctx.strokeStyle = "#ff0000";
           ctx.lineWidth = 4;
           ctx.setLineDash([10, 5]);
           ctx.beginPath();
           ctx.rect(heaterX - 5, heaterY - 5, heaterWidth + 10, heaterHeight + 10);
           ctx.stroke();
           ctx.setLineDash([]);
           
           // 접촉 텍스트
           ctx.font = "bold 16px sans-serif";
           ctx.fillStyle = "#ff0000";
           ctx.fillText("열 전달 중", heaterX + heaterWidth/2, heaterY + heaterHeight + 50);
         }
         
         ctx.restore();
       }
       
       // 전자들 업데이트 및 그리기
       thermalElectrons.forEach(electron => {
         // 고온 열원과의 접촉 확인 (맨 왼쪽 줄의 6개 원자)
         if (hotSourceContact && hotSourceVisible) {
           const spacing = densityCanvas.width / 7;
           const margin = spacing / 2;
           const leftColumnX = margin;
           
           // 전자가 맨 왼쪽 줄 근처에 있는지 확인
           if (electron.x >= leftColumnX - 20 && electron.x <= leftColumnX + 20) {
             // 열원 접촉 시 무작위한 방향으로 초기 속도 설정 (직접 열 전달 없음)
             const angle = Math.random() * 2 * Math.PI;
             const speed = 4 + Math.random() * 5;
             electron.vx = Math.cos(angle) * speed;
             electron.vy = Math.sin(angle) * speed;
           }
         }
         
         electron.update(atoms);
         electron.draw(ctx);
       });
       
       ctx.globalAlpha = 1.0;
       
       // 원자들 그리기 (온도와 충돌 횟수에 따른 색상 변화)
       atoms.forEach(([cx, cy], index) => {
         const atomRadiusPx = radiusToPixel(element.radius);
         const ionRadiusPx = ionRadiusToPixel(element.ionRadius);
         let temperature = atomTemperatures.get(index) || 0;
         const collisionCount = atomCollisionCounts.get(index) || 0;
         
         // 열원 근처의 두 원자를 고온으로 고정 (식지 않음)
         if (hotSourceContact && hotSourceVisible) {
           const heaterX = 20;
           const heaterWidth = 30;
           const heaterY = densityCanvas.height / 2;
           const heaterHeight = 140;
           const heaterTop = heaterY - heaterHeight / 2;
           const heaterBottom = heaterY + heaterHeight / 2;
           const heaterRight = heaterX + heaterWidth;
           
           // 맨 왼쪽 줄의 6개 원자를 고온으로 고정
           const spacing = densityCanvas.width / 7;
           const margin = spacing / 2;
           const leftColumnX = margin; // 맨 왼쪽 열의 x 좌표
           
           if (Math.abs(cx - leftColumnX) < 10) { // 맨 왼쪽 열에 있는 원자들
             // 맨 왼쪽 줄의 6개 원자를 고온으로 고정
             temperature = 200;
             atomTemperatures.set(index, 200);
           }
         }
         
         // 원자 반지름 원 (고정)
         ctx.save();
         ctx.globalAlpha = 0.5;
         ctx.beginPath();
         ctx.arc(cx, cy, atomRadiusPx, 0, 2 * Math.PI);
         ctx.strokeStyle = "#fff";
         ctx.lineWidth = 1.2;
         ctx.stroke();
         ctx.restore();
         
         // 금속양이온 (온도에 따른 색상 변화 - R값 고정, G,B 점차 감소)
         const r = 255; // R값 고정
         let g, b;
         
         if (temperature > 150) {
           // 150~200도: 진한 붉은색
           const t = Math.min((temperature - 150) / 50, 1);
           g = Math.round(50 * (1 - t)); // 50 → 0
           b = Math.round(50 * (1 - t)); // 50 → 0
         } else if (temperature > 100) {
           // 100~150도: 붉은색
           const t = (temperature - 100) / 50;
           g = Math.round(100 * (1 - t) + 50 * t); // 100 → 50
           b = Math.round(100 * (1 - t) + 50 * t); // 100 → 50
         } else if (temperature > 60) {
           // 60~100도: 분홍색
           const t = (temperature - 60) / 40;
           g = Math.round(150 * (1 - t) + 100 * t); // 150 → 100
           b = Math.round(150 * (1 - t) + 100 * t); // 150 → 100
         } else if (temperature > 30) {
           // 30~60도: 연분홍색
           const t = (temperature - 30) / 30;
           g = Math.round(200 * (1 - t) + 150 * t); // 200 → 150
           b = Math.round(200 * (1 - t) + 150 * t); // 200 → 150
         } else if (temperature > 10) {
           // 10~30도: 연한 분홍색
           const t = (temperature - 10) / 20;
           g = Math.round(240 * (1 - t) + 200 * t); // 240 → 200
           b = Math.round(240 * (1 - t) + 200 * t); // 240 → 200
         } else {
           // 0~10도: 흰색
           g = 255;
           b = 255;
         }
         
         const ionColor = `rgb(${r},${g},${b})`;
         
         ctx.beginPath();
         ctx.arc(cx, cy, ionRadiusPx, 0, 2 * Math.PI);
         ctx.fillStyle = ionColor;
         ctx.globalAlpha = 0.85;
         ctx.fill();
         ctx.globalAlpha = 1.0;
         ctx.strokeStyle = "#888";
         ctx.lineWidth = 1;
         ctx.stroke();
         
         // 온도가 높은 원자의 진동 효과
         if (temperature > 30) {
           const amplitude = (temperature - 30) / 170 * 3; // 30~200도 범위에서 진동
           const vibrationX = cx + amplitude * Math.cos(time * 5 + index);
           const vibrationY = cy + amplitude * Math.sin(time * 5 + index * 0.7);
           
           ctx.strokeStyle = "#ff6666";
           ctx.lineWidth = 1;
           ctx.globalAlpha = 0.3;
           ctx.beginPath();
           ctx.arc(cx, cy, amplitude, 0, 2 * Math.PI);
           ctx.stroke();
           ctx.globalAlpha = 1.0;
         }
         
         // 충돌 횟수가 많은 원자의 추가 효과
         if (collisionCount > 10) {
           // 충돌 횟수에 따른 글로우 효과
           const glowIntensity = Math.min(collisionCount / 50, 1);
           ctx.shadowColor = `rgba(255, 100, 0, ${glowIntensity * 0.5})`;
           ctx.shadowBlur = 10 + glowIntensity * 10;
           ctx.beginPath();
           ctx.arc(cx, cy, ionRadiusPx + 2, 0, 2 * Math.PI);
           ctx.fillStyle = `rgba(255, 100, 0, ${glowIntensity * 0.3})`;
           ctx.fill();
           ctx.shadowColor = 'transparent';
           ctx.shadowBlur = 0;
         }
         
         // 온도 유지 (감쇠 제거하여 붉은 상태 유지)
         // 온도는 다른 모드로 이동하거나 원소를 변경할 때만 초기화됨
       });
       
       // 열 전도 설명
       if (hotSourceContact) {
         ctx.save();
         ctx.font = "bold 16px sans-serif";
         ctx.fillStyle = "#ff6666";
         ctx.textAlign = "center";
         ctx.fillText("전자를 통한 열 전도", densityCanvas.width / 2, densityCanvas.height - 50);
         ctx.font = "14px sans-serif";
         ctx.fillText("고온 전자 → 원자 충돌 → 열 전달", densityCanvas.width / 2, densityCanvas.height - 30);
         ctx.restore();
       }
       
       // 프레임 레이트 제한 (성능 최적화)
       setTimeout(() => {
         heatAnimationId = requestAnimationFrame(animateHeatConduction);
       }, 16); // 약 60 FPS로 제한
     }

    // 전자 밀도 시각화 함수 (기존 함수 수정)
    function drawDensity(element, fieldOffset = 0, fieldActive = false, heatFront = 0, heatActive = false) {
      // 격자점 좌표 계산 (양이온 위치는 항상 고정, 여백 포함)
      const atoms = [];
      const currentGridSize = mode === "home" ? 5 : 6; // 초기화면: 5x5, 나머지: 6x6
      
              if (mode === "home") {
          // 초기화면: 정확히 5x5=25개 원자, 캔버스 중심에 배치
          const totalWidth = currentGridSize * spacing;
          const totalHeight = currentGridSize * spacing;
          const startX = (densityCanvas.width - totalWidth) / 2;
          const startY = (densityCanvas.height - totalHeight) / 2;
          
          for (let i = 0; i < currentGridSize; i++) {
            for (let j = 0; j < currentGridSize; j++) {
              atoms.push([startX + i * spacing + spacing/2, startY + j * spacing + spacing/2]);
            }
          }
      } else {
        // 다른 모드: 6x6 격자, 기존 방식
        const margin = spacing / 2;
        for (let i = 1; i <= currentGridSize; i++) {
          for (let j = 1; j <= currentGridSize; j++) {
            atoms.push([i * spacing + margin, j * spacing + margin]);
          }
        }
      }
      const sigma = radiusToSigma(element.radius);
      const intensity = element.valence;
      const atomRadiusPx = radiusToPixel(element.radius);
      const ionRadiusPx = ionRadiusToPixel(element.ionRadius);

      // 전자 밀도 계산 함수 개선
      function electronDensity(x, y) {
        let density = 0;
        
        // 1. 각 원자핵 주변의 핵심 전자밀도 (더 집중적)
        for (const [cx, cy] of atoms) {
          const dx = x - (mode === "electric" && fieldActive ? (cx + fieldOffset) : cx);
          const dy = y - cy;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          // 원자핵 주변: 더 집중된 분포
          if (dist < sigma * 0.8) {
            density += intensity * Math.exp(-(dist * dist) / (2 * (sigma * 0.5) * (sigma * 0.5)));
          }
          // 원자핵 외곽: 넓게 퍼진 분포
          else {
            density += intensity * 0.3 * Math.exp(-(dist * dist) / (2 * sigma * sigma));
          }
        }
        
        // 2. 원자 사이 공간의 전자밀도 연결 (결정 구조 반영)
        for (let i = 0; i < atoms.length; i++) {
          for (let j = i + 1; j < atoms.length; j++) {
            const [cx1, cy1] = atoms[i];
            const [cx2, cy2] = atoms[j];
            
            // 인접한 원자들 사이의 거리 계산
            const atomDist = Math.sqrt((cx2-cx1)*(cx2-cx1) + (cy2-cy1)*(cy2-cy1));
            
            // 인접한 원자들 사이에 전자밀도 연결
            if (atomDist < spacing * 1.5) {
              const midX = (cx1 + cx2) / 2;
              const midY = (cy1 + cy2) / 2;
              const dx = x - midX;
              const dy = y - midY;
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              // 원자 사이 공간의 전자밀도 (낮은 밀도)
              density += intensity * 0.2 * Math.exp(-(dist * dist) / (2 * (sigma * 0.8) * (sigma * 0.8)));
            }
          }
        }
        
        // 3. 전기장 효과 (기존과 동일)
        if (mode === "electric" && fieldActive) {
          const alpha = fieldOffset / 30 * 0.3;
          const grad = 1 + alpha * ((x - densityCanvas.width/2) / (densityCanvas.width/2));
          return density * grad;
        }
        
        return density;
      }

      // 전체 픽셀에 대해 전자 밀도 계산 및 색상 매핑
      const imageData = densityCtx.createImageData(densityCanvas.width, densityCanvas.height);
      let maxDensity = 0;
      const densities = new Float32Array(densityCanvas.width * densityCanvas.height);

      for (let y = 0; y < densityCanvas.height; y++) {
        for (let x = 0; x < densityCanvas.width; x++) {
          const d = electronDensity(x, y);
          densities[y * densityCanvas.width + x] = d;
          if (d > maxDensity) maxDensity = d;
        }
      }

      for (let y = 0; y < densityCanvas.height; y++) {
        for (let x = 0; x < densityCanvas.width; x++) {
          const d = densities[y * densityCanvas.width + x] / maxDensity;
          let r, g, b;
          if (mode === "thermal" && heatActive && x < heatFront) {
            // 열이 퍼진 영역은 빨간색 계열
            r = 255;
            g = Math.round(150 + d * 105);
            b = Math.round(80 + d * 100);
          } else {
            // 원래 금속 색상 계열
            const base = element.color;
            const r0 = parseInt(base.slice(1,3),16);
            const g0 = parseInt(base.slice(3,5),16);
            const b0 = parseInt(base.slice(5,7),16);
            r = Math.round(r0 + d * (255 - r0));
            g = Math.round(g0 + d * (255 - g0));
            b = Math.round(b0 + d * (255 - b0));
          }
          const a = 255;
          const idx = (y * densityCanvas.width + x) * 4;
          imageData.data[idx] = r;
          imageData.data[idx + 1] = g;
          imageData.data[idx + 2] = b;
          imageData.data[idx + 3] = a;
        }
      }
      densityCtx.putImageData(imageData, 0, 0);
    }
    
    // 설명 텍스트 업데이트 함수 수정
    function updateDesc() {
      const element = elements[select.value];
      let html = '';
      unitCellInfo.innerHTML = ''; // Clear by default

      switch (mode) {
          case 'electric':
              html = `<b>금속의 전기전도성</b><br>
               자유전자가 전기장 방향으로 연속적으로 흐르며<br>
               화면 끝에서 사라진 전자는 왼쪽에서 새로운 전자로 나타납니다.<br>
               <span style='color:#ffeb3b'>[스위치]</span>를 켜서 전류 흐름을 관찰해보세요.`;
              break;
          case 'thermal':
              html = `<b>금속의 열전도성</b><br>
               열원에 접촉한 전자가 자유롭고 무작위하게 움직이며<br>
               고온의 전자와 충돌한 원자는 온도가 증가합니다.<br>
               <span style='color:#ffeb3b'>[열 가하기]</span> 버튼을 눌러 열 전달을 관찰해보세요.`;
              break;
          case 'ductility':
              html = `<b>금속의 연성과 전성</b><br>
              금속 양이온의 한 층이 미끄러지듯 이동해도<br>
              자유전자가 결합을 유지하여 구조가 끊어지지 않습니다.<br>
              <span style='color:#ffeb3b'>[변형 가하기] 버튼</span>을 눌러 층의 이동을 관찰해보세요.`;
              break;
          case 'luster':
              html = `<b>금속의 광택과 에너지 준위</b><br>
              금속은 자유전자가 대부분의 가시광선을 흡수하고 재방출하여<br>
              특유의 광택을 나타냅니다. 원자 수 증가에 따라<br>
              원자 오비탈이 에너지 밴드로 변화하는 과정을 관찰해보세요.`;
              leftTitle.textContent = '금속 결정 구조와 에너지 준위';
              break;
          case 'home':
          default:
              html = `<b>금속결정의 전자밀도 시각화</b><br>
              이 모형은 금속결정 내에서 전자들이 원자에 속박되지 않고<br>
              전체에 걸쳐 자유롭게 퍼져 있는 모습을 시각화합니다.<br>
              왼쪽: 각 격자점은 금속 양이온(원자핵)의 위치를, 퍼진 구름은 전자 밀도를 나타냅니다.<br>
              오른쪽: 금속 결정의 단위세포 구조를 3D로 확인할 수 있습니다.<br>
              마우스로 드래그하여 단위세포를 회전시켜보세요.<br>
              상단의 '전기 전도성', '열 전도성' 버튼을 누르면<br>
              금속의 물리적 성질을 시각적으로 체험할 수 있습니다.`;
              unitCellInfo.innerHTML = `
                <strong>${element.name} (${element.symbol})</strong><br>
                격자 구조: ${element.description}<br>
                단위세포 크기: ${element.unitCell.a} pm<br>
                원자 반지름: ${element.radius} pm | 이온 반지름: ${element.ionRadius} pm
              `;
              break;
      }
      desc.innerHTML = html;
    }

    // 3D 단위세포 그리기 함수 (기존 함수 복원)
    function drawUnitCell(element) {
      const ctx = unitCellCtx;
      const width = unitCellCanvas.width;
      const height = unitCellCanvas.height;
      
      ctx.clearRect(0, 0, width, height);
      
      // 3D 변환을 위한 설정
      const centerX = width / 2;
      const centerY = height / 2;
      const scale = 80; // 단위세포 크기 스케일
      
      // 격자 구조에 따른 원자 위치 계산
      let atoms = [];
      
      if (element.lattice === "BCC") {
        // 체심입방격자: 8개 모서리 + 1개 중심
        const corners = [
          [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
          [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
        ];
        
        // 모서리 원자들 (모든 원자 크기 통일)
        corners.forEach(([x, y, z]) => {
          atoms.push([x * scale, y * scale, z * scale, 1.0]);
        });
        // 중심 원자
        atoms.push([0, 0, 0, 1.0]);
        
      } else if (element.lattice === "FCC") {
        // 면심입방격자: 8개 모서리 + 6개 면심
        const corners = [
          [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],
          [-1, -1, 1], [1, -1, 1], [1, 1, 1], [-1, 1, 1]
        ];
        const faceCenters = [
          // 앞면과 뒷면의 중심
          [0, 0, -1], [0, 0, 1],
          // 왼쪽면과 오른쪽면의 중심
          [-1, 0, 0], [1, 0, 0],
          // 아래면과 위면의 중심
          [0, -1, 0], [0, 1, 0]
        ];
        
        // 모서리 원자들 (모든 원자 크기 통일)
        corners.forEach(([x, y, z]) => {
          atoms.push([x * scale, y * scale, z * scale, 1.0]);
        });
        // 면심 원자들 (모든 원자 크기 통일)
        faceCenters.forEach(([x, y, z]) => {
          atoms.push([x * scale, y * scale, z * scale, 1.0]);
        });
      }
      
      // 3D 회전 적용
      const cosX = Math.cos(rotationX);
      const sinX = Math.sin(rotationX);
      const cosY = Math.cos(rotationY);
      const sinY = Math.sin(rotationY);
      
      // 원자들을 Z축 순으로 정렬 (깊이 정렬)
      const sortedAtoms = atoms.map(([x, y, z, size]) => {
        // Y축 회전
        const x1 = x * cosY - z * sinY;
        const z1 = x * sinY + z * cosY;
        // X축 회전
        const y1 = y * cosX - z1 * sinX;
        const z2 = y * sinX + z1 * cosX;
        
        return {
          x: x1 + centerX,
          y: y1 + centerY,
          z: z2,
          size: size * 15, // 원자 크기
          originalZ: z2
        };
      }).sort((a, b) => b.originalZ - a.originalZ);
      
      // 격자선 그리기
      ctx.strokeStyle = "#444";
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.3;
      
      // 격자선 (간단한 윤곽선)
      const edges = [
        // 아래면
        [-scale, -scale, -scale], [scale, -scale, -scale],
        [scale, -scale, -scale], [scale, scale, -scale],
        [scale, scale, -scale], [-scale, scale, -scale],
        [-scale, scale, -scale], [-scale, -scale, -scale],
        // 위면
        [-scale, -scale, scale], [scale, -scale, scale],
        [scale, -scale, scale], [scale, scale, scale],
        [scale, scale, scale], [-scale, scale, scale],
        [-scale, scale, scale], [-scale, -scale, scale],
        // 연결선
        [-scale, -scale, -scale], [-scale, -scale, scale],
        [scale, -scale, -scale], [scale, -scale, scale],
        [scale, scale, -scale], [scale, scale, scale],
        [-scale, scale, -scale], [-scale, scale, scale]
      ];
      
      for (let i = 0; i < edges.length; i += 2) {
        const [x1, y1, z1] = edges[i];
        const [x2, y2, z2] = edges[i + 1];
        
        // 회전 적용
        const x1r = (x1 * cosY - z1 * sinY) * cosX - (y1 * cosX - z1 * sinX) * sinX + centerX;
        const y1r = (y1 * cosX - z1 * sinX) + centerY;
        const x2r = (x2 * cosY - z2 * sinY) * cosX - (y2 * cosX - z2 * sinX) * sinX + centerX;
        const y2r = (y2 * cosX - z2 * sinX) + centerY;
        
        ctx.beginPath();
        ctx.moveTo(x1r, y1r);
        ctx.lineTo(x2r, y2r);
        ctx.stroke();
      }
      
      // 원자 그리기
      ctx.globalAlpha = 1.0;
      sortedAtoms.forEach(atom => {
        ctx.fillStyle = element.color;
        ctx.beginPath();
        ctx.arc(atom.x, atom.y, atom.size, 0, 2 * Math.PI);
        ctx.fill();
        
        // 원자 외곽선
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        ctx.stroke();
      });
    }

         // 전체 그리기 함수
     function draw() {
       const element = currentElement || elements[select.value];
       if (mode === 'ductility') {
         return drawDuctility();
       } else if (mode === 'luster') {
         return drawLuster();
       }
       if (mode === "electric") {
         // 전기전도성 모드에서는 전자 시뮬레이션 실행
         if (!electronAnimationId) {
           initElectrons();
           animateElectrons();
         }
         if (heatAnimationId) {
           cancelAnimationFrame(heatAnimationId);
           heatAnimationId = null;
         }
       } else if (mode === "thermal") {
         // 열전도성 모드에서는 전자 기반 열전도 시뮬레이션 실행
         if (!heatAnimationId) {
           initThermalElectrons();
           animateHeatConduction();
         }
         if (electronAnimationId) {
           cancelAnimationFrame(electronAnimationId);
           electronAnimationId = null;
         }
       } else {
         // 처음으로 모드에서는 기존 방식으로 그리기
         if (electronAnimationId) {
           cancelAnimationFrame(electronAnimationId);
           electronAnimationId = null;
         }
         if (heatAnimationId) {
           cancelAnimationFrame(heatAnimationId);
           heatAnimationId = null;
         }
         drawDensity(element, fieldOffset, fieldActive, heatFront, heatActive);
         if (mode === "home") {
           drawUnitCell(element);
         }
       }
     }

         // 전자 밀도 시각화 함수 (캐싱 시스템 적용)
     function drawDensity(element, fieldOffset = 0, fieldActive = false, heatFront = 0, heatActive = false) {
       // 캐시 무효화 체크
       const needsRedraw = cacheInvalid || 
                          lastElement !== element || 
                          lastMode !== mode || 
                          (mode === "ductility" && lastDeformOffset !== deformOffset);
       
       if (!needsRedraw) {
         // 캐시된 배경을 메인 캔버스에 복사
         densityCtx.clearRect(0, 0, densityCanvas.width, densityCanvas.height);
         densityCtx.drawImage(backgroundCanvas, 0, 0);
         return;
       }
       
       // 캐시 무효화 플래그 업데이트
       cacheInvalid = false;
       lastElement = element;
       lastMode = mode;
       lastDeformOffset = deformOffset;
       
       // 격자점 좌표 계산 (양이온 위치는 항상 고정) - 여백 포함
       const atoms = [];
       const currentGridSize = mode === "home" ? 5 : 6; // 초기화면: 5x5, 나머지: 6x6
       
       if (mode === "home") {
         // 초기화면: 정확히 5x5=25개 원자, 캔버스 중심에 배치
         const totalWidth = currentGridSize * spacing;
         const totalHeight = currentGridSize * spacing;
         const startX = (densityCanvas.width - totalWidth) / 2;
         const startY = (densityCanvas.height - totalHeight) / 2;
         
         for (let i = 0; i < currentGridSize; i++) {
           for (let j = 0; j < currentGridSize; j++) {
             atoms.push([startX + i * spacing + spacing/2, startY + j * spacing + spacing/2]);
           }
         }
       } else {
         // 다른 모드: 6x6 격자, 기존 방식
         const margin = spacing / 2;
         for (let i = 0; i <= Math.floor(densityCanvas.width / spacing); i++) {
           for (let j = 0; j <= Math.floor(densityCanvas.height / spacing); j++) {
             const x = i * spacing + margin;
             const y = j * spacing + margin;
             if (x < densityCanvas.width && y < densityCanvas.height) {
               atoms.push([x, y]);
             }
           }
         }
       }
      const sigma = radiusToSigma(element.radius);
      const intensity = element.valence;
      const atomRadiusPx = radiusToPixel(element.radius);
      const ionRadiusPx = ionRadiusToPixel(element.ionRadius);

      // 전자 밀도 계산 함수 개선
      function electronDensity(x, y) {
        let density = 0;
        
        // 1. 각 원자핵 주변의 핵심 전자밀도 (더 집중적)
        for (const [cx, cy] of atoms) {
          const dx = x - (mode === "electric" && fieldActive ? (cx + fieldOffset) : cx);
          const dy = y - cy;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          // 원자핵 주변: 더 집중된 분포
          if (dist < sigma * 0.8) {
            density += intensity * Math.exp(-(dist * dist) / (2 * (sigma * 0.5) * (sigma * 0.5)));
          }
          // 원자핵 외곽: 넓게 퍼진 분포
          else {
            density += intensity * 0.3 * Math.exp(-(dist * dist) / (2 * sigma * sigma));
          }
        }
        
        // 2. 원자 사이 공간의 전자밀도 연결 (결정 구조 반영)
        for (let i = 0; i < atoms.length; i++) {
          for (let j = i + 1; j < atoms.length; j++) {
            const [cx1, cy1] = atoms[i];
            const [cx2, cy2] = atoms[j];
            
            // 인접한 원자들 사이의 거리 계산
            const atomDist = Math.sqrt((cx2-cx1)*(cx2-cx1) + (cy2-cy1)*(cy2-cy1));
            
            // 인접한 원자들 사이에 전자밀도 연결
            if (atomDist < spacing * 1.5) {
              const midX = (cx1 + cx2) / 2;
              const midY = (cy1 + cy2) / 2;
              const dx = x - midX;
              const dy = y - midY;
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              // 원자 사이 공간의 전자밀도 (낮은 밀도)
              density += intensity * 0.2 * Math.exp(-(dist * dist) / (2 * (sigma * 0.8) * (sigma * 0.8)));
            }
          }
        }
        
        // 3. 전기장 효과 (기존과 동일)
        if (mode === "electric" && fieldActive) {
          const alpha = fieldOffset / 30 * 0.3;
          const grad = 1 + alpha * ((x - densityCanvas.width/2) / (densityCanvas.width/2));
          return density * grad;
        }
        
        return density;
      }

      // 전체 픽셀에 대해 전자 밀도 계산 및 색상 매핑
      const imageData = densityCtx.createImageData(densityCanvas.width, densityCanvas.height);
      let maxDensity = 0;
      const densities = new Float32Array(densityCanvas.width * densityCanvas.height);

      for (let y = 0; y < densityCanvas.height; y++) {
        for (let x = 0; x < densityCanvas.width; x++) {
          const d = electronDensity(x, y);
          densities[y * densityCanvas.width + x] = d;
          if (d > maxDensity) maxDensity = d;
        }
      }

      for (let y = 0; y < densityCanvas.height; y++) {
        for (let x = 0; x < densityCanvas.width; x++) {
          const d = densities[y * densityCanvas.width + x] / maxDensity;
          let r, g, b;
          if (mode === "thermal" && heatActive && x < heatFront) {
            // 열이 퍼진 영역은 빨간색 계열
            r = 255;
            g = Math.round(150 + d * 105);
            b = Math.round(80 + d * 100);
          } else {
            // 원래 금속 색상 계열
            const base = element.color;
            const r0 = parseInt(base.slice(1,3),16);
            const g0 = parseInt(base.slice(3,5),16);
            const b0 = parseInt(base.slice(5,7),16);
            r = Math.round(r0 + d * (255 - r0));
            g = Math.round(g0 + d * (255 - g0));
            b = Math.round(b0 + d * (255 - b0));
          }
          const a = 255;
          const idx = (y * densityCanvas.width + x) * 4;
          imageData.data[idx] = r;
          imageData.data[idx + 1] = g;
          imageData.data[idx + 2] = b;
          imageData.data[idx + 3] = a;
        }
      }
      
      // 배경을 오프스크린 캔버스에 그리기
      backgroundCtx.putImageData(imageData, 0, 0);

      // 격자점(양이온) 및 원자 반지름, 금속양이온 반지름 표시 (항상 고정)
      backgroundCtx.strokeStyle = "#fff";
      backgroundCtx.lineWidth = 2;
      backgroundCtx.font = "14px sans-serif";
      backgroundCtx.textAlign = "center";
      backgroundCtx.textBaseline = "top";
      backgroundCtx.fillStyle = "#fff";
      for (const [cx, cy] of atoms) {
        // 원자 반지름(실제 크기) 원 그리기
        backgroundCtx.save();
        backgroundCtx.globalAlpha = 0.5;
        backgroundCtx.beginPath();
        backgroundCtx.arc(cx, cy, atomRadiusPx, 0, 2 * Math.PI);
        backgroundCtx.strokeStyle = "#fff";
        backgroundCtx.lineWidth = 1.2;
        backgroundCtx.stroke();
        backgroundCtx.restore();
        // 금속양이온(실제 크기) 그리기
        backgroundCtx.beginPath();
        backgroundCtx.arc(cx, cy, ionRadiusPx, 0, 2 * Math.PI);
        backgroundCtx.fillStyle = "#fff";
        backgroundCtx.globalAlpha = 0.85;
        backgroundCtx.fill();
        backgroundCtx.globalAlpha = 1.0;
        backgroundCtx.strokeStyle = "#888";
        backgroundCtx.lineWidth = 1;
        backgroundCtx.stroke();
      }
      
      // 한 곳에 원자 반지름 길이(pm)와 금속양이온 반지름(pm) 표시 (왼쪽 위 첫 번째 원자)
      const [cx, cy] = atoms[0];
      backgroundCtx.save();
      // 원자 반지름
      backgroundCtx.strokeStyle = "#ff6666";
      backgroundCtx.lineWidth = 2;
      backgroundCtx.beginPath();
      backgroundCtx.moveTo(cx, cy);
      backgroundCtx.lineTo(cx + atomRadiusPx, cy);
      backgroundCtx.stroke();
      backgroundCtx.fillStyle = "#ff6666";
      backgroundCtx.font = "bold 14px sans-serif";
      backgroundCtx.textAlign = "left";
      backgroundCtx.textBaseline = "bottom";
      backgroundCtx.fillText(`${element.radius} pm (원자)`, cx + atomRadiusPx/2 + 5, cy - 4);
      // 금속양이온 반지름
      backgroundCtx.strokeStyle = "#00ff99";
      backgroundCtx.lineWidth = 2;
      backgroundCtx.beginPath();
      backgroundCtx.moveTo(cx, cy);
      backgroundCtx.lineTo(cx + ionRadiusPx, cy + 12);
      backgroundCtx.stroke();
      backgroundCtx.fillStyle = "#00ff99";
      backgroundCtx.font = "bold 14px sans-serif";
      backgroundCtx.textAlign = "left";
      backgroundCtx.textBaseline = "top";
      backgroundCtx.fillText(`${element.ionRadius} pm (이온)`, cx + ionRadiusPx/2 + 5, cy + 12 + 4);
      backgroundCtx.restore();

      // 전기장(→) 또는 열(→) 표시
      if (mode === "electric" && fieldActive) {
        backgroundCtx.save();
        // 화살표 몸통 (검은색 외곽선 + 노란색 채우기)
        backgroundCtx.strokeStyle = "#000";
        backgroundCtx.fillStyle = "#ffeb3b";
        backgroundCtx.lineWidth = 3;
        backgroundCtx.beginPath();
        backgroundCtx.moveTo(densityCanvas.width - 120, densityCanvas.height - 40);
        backgroundCtx.lineTo(densityCanvas.width - 40, densityCanvas.height - 40);
        backgroundCtx.stroke();
        // 화살촉 (검은색 외곽선 + 노란색 채우기)
        backgroundCtx.beginPath();
        backgroundCtx.moveTo(densityCanvas.width - 40, densityCanvas.height - 40);
        backgroundCtx.lineTo(densityCanvas.width - 55, densityCanvas.height - 50);
        backgroundCtx.lineTo(densityCanvas.width - 55, densityCanvas.height - 30);
        backgroundCtx.closePath();
        backgroundCtx.fill();
        backgroundCtx.stroke();
        // 텍스트 (노란색에 검은색 외곽선)
        backgroundCtx.font = "bold 20px sans-serif";
        backgroundCtx.textAlign = "center";
        backgroundCtx.textBaseline = "bottom";
        backgroundCtx.strokeStyle = "#000";
        backgroundCtx.lineWidth = 2;
        backgroundCtx.strokeText("전기장 E", densityCanvas.width - 80, densityCanvas.height - 60);
        backgroundCtx.fillStyle = "#ffeb3b";
        backgroundCtx.fillText("전기장 E", densityCanvas.width - 80, densityCanvas.height - 60);
        backgroundCtx.restore();
      }
      if (mode === "thermal" && heatActive) {
        backgroundCtx.save();
        backgroundCtx.strokeStyle = "#ff5722";
        backgroundCtx.fillStyle = "#ff5722";
        backgroundCtx.lineWidth = 4;
        backgroundCtx.beginPath();
        backgroundCtx.moveTo(40, densityCanvas.height - 40);
        backgroundCtx.lineTo(120, densityCanvas.height - 40);
        backgroundCtx.stroke();
        backgroundCtx.beginPath();
        backgroundCtx.moveTo(120, densityCanvas.height - 40);
        backgroundCtx.lineTo(105, densityCanvas.height - 50);
        backgroundCtx.lineTo(105, densityCanvas.height - 30);
        backgroundCtx.closePath();
        backgroundCtx.fill();
        backgroundCtx.font = "bold 18px sans-serif";
        backgroundCtx.fillText("열 흐름", 80, densityCanvas.height - 60);
        backgroundCtx.restore();
      }
      
      // 배경을 메인 캔버스에 복사
      densityCtx.clearRect(0, 0, densityCanvas.width, densityCanvas.height);
      densityCtx.drawImage(backgroundCanvas, 0, 0);
    }

    // 애니메이션 함수
    function animateField() {
      if (!fieldActive) return;
      animating = true;
      fieldOffset += 2.5;
      if (fieldOffset > 30) fieldOffset = 30;
      draw();
      if (fieldOffset < 30) {
        animationFrame = requestAnimationFrame(animateField);
      } else {
        animating = false;
      }
    }
         function animateHeat() {
       if (!heatActive) return;
       animating = true;
       heatFront += 8;
       hotObjectTemp += 2; // 온도 점진적 증가
       if (heatFront > densityCanvas.width) heatFront = densityCanvas.width;
       if (hotObjectTemp > 500) hotObjectTemp = 500; // 최대 온도 제한
       draw();
       if (heatFront < densityCanvas.width) {
         animationFrame = requestAnimationFrame(animateHeat);
       } else {
         animating = false;
       }
     }

         // 스위치 토글 함수
     function toggleSwitch() {
       switchOn = !switchOn;
       electricSwitch.checked = switchOn;
       switchStatus.textContent = switchOn ? "ON" : "OFF";
       switchStatus.style.color = switchOn ? "#00ff00" : "#ff0000";
     }

    // UI 이벤트
    select.addEventListener('change', () => {
      // 원소 변경 시 온도와 충돌 횟수 초기화
      atomTemperatures.clear();
      atomCollisionCounts.clear();
      resetAll();
      cacheInvalid = true; // 캐시 무효화
      const element = elements[select.value];
      currentElement = element;
      if (mode === "electric") {
        // 전기전도성 모드에서는 전자 시뮬레이션 재시작
        if (electronAnimationId) {
          cancelAnimationFrame(electronAnimationId);
          electronAnimationId = null;
        }
        initElectrons();
        animateElectrons();
      } else if (mode === "thermal") {
        // 열전도성 모드에서는 열전도 시뮬레이션 재시작
        if (heatAnimationId) {
          cancelAnimationFrame(heatAnimationId);
          heatAnimationId = null;
        }
        initThermalElectrons();
        animateHeatConduction();
      } else {
        drawDensity(element, fieldOffset, fieldActive, heatFront, heatActive);
        if (mode === "home") {
          drawUnitCell(element);
        }
      }
      updateDesc();
    });

         // 스위치 체크박스 이벤트
     electricSwitch.addEventListener('change', (e) => {
       if (mode === "electric") {
         switchOn = e.target.checked;
         switchStatus.textContent = switchOn ? "ON" : "OFF";
         switchStatus.style.color = switchOn ? "#00ff00" : "#ff0000";
       }
     });

    // 기존 이벤트 리스너들 수정
    fieldBtn.addEventListener('click', () => {
      if (animating) return;
      fieldActive = true;
      fieldOffset = 0;
      animateField();
    });

    heatBtn.addEventListener('click', () => {
      if (animating) return;
      heatActive = true;
      heatFront = 0;
      hotSourceVisible = true;
      hotSourceContact = true;
      
      if (mode === "thermal") {
        // 열전도성 모드에서는 전자 기반 열전도 시뮬레이션 실행
        if (!heatAnimationId) {
          // 기존 온도 유지 (초기화하지 않음)
          initThermalElectrons();
          animateHeatConduction();
        }
      } else {
        // 다른 모드에서는 기존 열 애니메이션 실행
        animateHeat();
      }
    });

         modeElectric.addEventListener('click', () => {
       if (mode === "electric") return;
       // 다른 모드의 변경사항 초기화
       atomTemperatures.clear();
       atomCollisionCounts.clear();
       customAtoms = [];
       atomCount = 0;
       deformActive = false;
       deformOffset = 0;
       spectrumActive = false;
       isSolidState = false;
       mode = "electric";
       cacheInvalid = true; // 캐시 무효화
       // 애니메이션 중지 및 전자 배열 초기화
       if (electronAnimationId) {
         cancelAnimationFrame(electronAnimationId);
         electronAnimationId = null;
       }
       if (heatAnimationId) {
         cancelAnimationFrame(heatAnimationId);
         heatAnimationId = null;
       }
       electrons = []; // 전자 배열 초기화
       thermalElectrons = []; // 열전도성 전자 배열 초기화
       modeElectric.classList.add("active");
       modeThermal.classList.remove("active");
       modeDuctility.classList.remove("active");
       modeLuster.classList.remove("active");
       // 다른 모드 버튼들 비활성화
       disableOtherModeButtons(modeElectric);
       fieldBtn.style.display = "none"; // 전기장 버튼 숨김
       heatBtn.style.display = "none";
       deformBtn.style.display = "none";
       switchContainer.style.display = "block"; // 스위치 표시
       spectrumContainer.style.display = "none";
       atomControls.style.display = "none";
       document.getElementById('theory-container').style.display = "none";
       homeBtn.classList.remove("active");
       // 전기전도성 모드에서는 단위세포 숨김
       document.querySelector('.right-panel').style.display = "none";
       document.querySelector('.left-panel').style.width = "100%";
       resetAll();
       updateDesc();
       draw();
     });

         modeThermal.addEventListener('click', () => {
       if (mode === "thermal") return;
       // 다른 모드의 변경사항 초기화
       customAtoms = [];
       atomCount = 0;
       deformActive = false;
       deformOffset = 0;
       spectrumActive = false;
       isSolidState = false;
       switchOn = false;
       electricSwitch.checked = false;
       switchStatus.textContent = "OFF";
       switchStatus.style.color = "#ff0000";
                mode = "thermal";
         cacheInvalid = true; // 캐시 무효화
         // 애니메이션 중지 및 전자 배열 초기화
         if (electronAnimationId) {
           cancelAnimationFrame(electronAnimationId);
           electronAnimationId = null;
         }
         if (heatAnimationId) {
           cancelAnimationFrame(heatAnimationId);
           heatAnimationId = null;
         }
         electrons = []; // 전자 배열 초기화
         thermalElectrons = []; // 열전도성 전자 배열 초기화
         modeElectric.classList.remove("active");
       modeThermal.classList.add("active");
       modeDuctility.classList.remove("active");
       modeLuster.classList.remove("active");
       // 다른 모드 버튼들 비활성화
       disableOtherModeButtons(modeThermal);
       fieldBtn.style.display = "none";
       heatBtn.style.display = "";
       deformBtn.style.display = "none";
       switchContainer.style.display = "none"; // 스위치 숨김
       spectrumContainer.style.display = "none";
       atomControls.style.display = "none";
       document.getElementById('theory-container').style.display = "none";
       homeBtn.classList.remove("active");
       // 열전도성 모드에서는 단위세포 숨김
       document.querySelector('.right-panel').style.display = "none";
       document.querySelector('.left-panel').style.width = "100%";
       resetAll();
       updateDesc();
       draw();
     });

         homeBtn.addEventListener('click', () => {
       // 페이지 새로고침으로 모든 상태 완전 초기화
       location.reload();
     });

         function resetAll() {
       // 모든 모드에서 온도와 충돌 횟수 초기화 (모드 변경 시 완전 초기화)
       atomTemperatures.clear();
       atomCollisionCounts.clear();
       switchOn = false; // 스위치도 리셋
       electricSwitch.checked = false;
       switchStatus.textContent = "OFF";
       switchStatus.style.color = "#ff0000";
       deformActive = false;
       deformOffset = 0;
       spectrumActive = false;
       isSolidState = false;
       customAtoms = [];
       atomCount = 0;
       isAddingMode = true;
       cacheInvalid = true; // 캐시 무효화
       // 모든 애니메이션 중지 및 전자 배열 초기화
       if (animationFrame) {
         cancelAnimationFrame(animationFrame);
         animationFrame = null;
       }
       if (electronAnimationId) {
         cancelAnimationFrame(electronAnimationId);
         electronAnimationId = null;
       }
       if (heatAnimationId) {
         cancelAnimationFrame(heatAnimationId);
         heatAnimationId = null;
       }
       electrons = []; // 전자 배열 초기화
       thermalElectrons = []; // 열전도성 전자 배열 초기화
     }

    // 마우스 이벤트 처리 (단위세포용)
    unitCellCanvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });
    
    unitCellCanvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;
      
      rotationY += deltaX * 0.01;
      rotationX += deltaY * 0.01;
      
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      
      const element = elements[select.value];
      drawUnitCell(element);
    });
    
    unitCellCanvas.addEventListener('mouseup', () => {
      isDragging = false;
    });
    
    unitCellCanvas.addEventListener('mouseleave', () => {
      isDragging = false;
    });

    // 전자밀도 캔버스 클릭 이벤트 (원자 추가/제거용)
    densityCanvas.addEventListener('click', (e) => {
      if (mode !== 'luster') return;
      
      const rect = densityCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      if (isAddingMode) {
        // 원자 추가
        addAtom(x, y);
      } else {
        // 원자 제거
        removeAtom(x, y);
      }
    });

    // 최초 실행
    mode = "home";
    currentElement = elements[0];
    homeBtn.classList.add("active");
    modeElectric.classList.remove("active");
    modeThermal.classList.remove("active");
    fieldBtn.style.display = "none";
    heatBtn.style.display = "none";
    updateDesc();
    drawDensity(elements[0], 0, false, 0, false);
    drawUnitCell(elements[0]);
    drawSpectrum(); // 초기 스펙트럼 그리기

    // 1. 모드 버튼 이벤트 추가
    modeDuctility.addEventListener('click', () => {
      if (mode === 'ductility') return;
      // 다른 모드의 변경사항 초기화
      atomTemperatures.clear();
      atomCollisionCounts.clear();
      customAtoms = [];
      atomCount = 0;
      spectrumActive = false;
      isSolidState = false;
      switchOn = false;
      electricSwitch.checked = false;
      switchStatus.textContent = "OFF";
      switchStatus.style.color = "#ff0000";
      mode = 'ductility';
      cacheInvalid = true; // 캐시 무효화
      // 애니메이션 중지 및 전자 배열 초기화
      if (electronAnimationId) {
        cancelAnimationFrame(electronAnimationId);
        electronAnimationId = null;
      }
      if (heatAnimationId) {
        cancelAnimationFrame(heatAnimationId);
        heatAnimationId = null;
      }
      electrons = []; // 전자 배열 초기화
      thermalElectrons = []; // 열전도성 전자 배열 초기화
      modeElectric.classList.remove('active');
      modeThermal.classList.remove('active');
      modeDuctility.classList.add('active');
      modeLuster.classList.remove('active');
      // 다른 모드 버튼들 비활성화
      disableOtherModeButtons(modeDuctility);
      fieldBtn.style.display = 'none';
      heatBtn.style.display = 'none';
      deformBtn.style.display = '';
      // 변형 가하기 버튼 상태 초기화
      deformBtn.disabled = false;
      deformBtn.textContent = '변형 가하기';
      deformBtn.style.opacity = '1.0';
      deformBtn.style.cursor = 'pointer';
      switchContainer.style.display = 'none';
      spectrumContainer.style.display = 'none';
      atomControls.style.display = 'none';
      document.getElementById('theory-container').style.display = 'none';
      homeBtn.classList.remove('active');
      document.querySelector('.right-panel').style.display = 'none';
      document.querySelector('.left-panel').style.width = '100%';
      resetAll();
      updateDesc();
      draw();
    });

    modeLuster.addEventListener('click', () => {
      if (mode === 'luster') return;
      // 다른 모드의 변경사항 초기화
      atomTemperatures.clear();
      atomCollisionCounts.clear();
      deformActive = false;
      deformOffset = 0;
      switchOn = false;
      electricSwitch.checked = false;
      switchStatus.textContent = "OFF";
      switchStatus.style.color = "#ff0000";
      mode = 'luster';
      cacheInvalid = true; // 캐시 무효화
      // 애니메이션 중지 및 전자 배열 초기화
      if (electronAnimationId) {
        cancelAnimationFrame(electronAnimationId);
        electronAnimationId = null;
      }
      if (heatAnimationId) {
        cancelAnimationFrame(heatAnimationId);
        heatAnimationId = null;
      }
      electrons = []; // 전자 배열 초기화
      thermalElectrons = []; // 열전도성 전자 배열 초기화
      modeElectric.classList.remove('active');
      modeThermal.classList.remove('active');
      modeDuctility.classList.remove('active');
      modeLuster.classList.add('active');
      // 다른 모드 버튼들 비활성화
      disableOtherModeButtons(modeLuster);
      fieldBtn.style.display = 'none';
      heatBtn.style.display = 'none';
      deformBtn.style.display = 'none';
      switchContainer.style.display = 'none';
      spectrumContainer.style.display = 'block';
      atomControls.style.display = 'block';
      document.getElementById('theory-container').style.display = 'block';
      homeBtn.classList.remove('active');
      document.querySelector('.right-panel').style.display = 'none';
      document.querySelector('.left-panel').style.width = '100%';
      resetAll();
      updateDesc();
      draw();
      updateAtomControls();
    });

    deformBtn.addEventListener('click', () => {
      // 이미 진행 중이면 클릭 무시
      if (deformBtn.disabled) return;
      
      deformActive = !deformActive;
      cacheInvalid = true; // 캐시 무효화 (변형 시작/종료)
      
      // 버튼 비활성화 및 텍스트 변경
      deformBtn.disabled = true;
      deformBtn.textContent = deformActive ? '변형 진행 중...' : '복원 진행 중...';
      deformBtn.style.opacity = '0.6';
      deformBtn.style.cursor = 'not-allowed';
      
      animateDuctility();
    });



    addAtomBtn.addEventListener('click', () => {
      isAddingMode = true;
      addAtomBtn.style.background = '#4CAF50';
      removeAtomBtn.style.background = '#666';
      updateAtomControls();
    });

    removeAtomBtn.addEventListener('click', () => {
      isAddingMode = false;
      addAtomBtn.style.background = '#666';
      removeAtomBtn.style.background = '#f44336';
      updateAtomControls();
    });

         // 2. 연성과 전성 시각화 함수 (캐싱 시스템 적용)
     function drawDuctility() {
       const element = currentElement || elements[select.value];
       
       // 캐시 무효화 체크
       const needsRedraw = cacheInvalid || 
                          lastElement !== element || 
                          lastMode !== mode || 
                          lastDeformOffset !== deformOffset;
       
       if (!needsRedraw) {
         // 캐시된 배경을 메인 캔버스에 복사
         densityCtx.clearRect(0, 0, densityCanvas.width, densityCanvas.height);
         densityCtx.drawImage(backgroundCanvas, 0, 0);
         return;
       }
       
       // 캐시 무효화 플래그 업데이트
       cacheInvalid = false;
       lastElement = element;
       lastMode = mode;
       lastDeformOffset = deformOffset;
       
       const ctx = backgroundCtx; // 오프스크린 캔버스에 그리기
       ctx.clearRect(0, 0, densityCanvas.width, densityCanvas.height);
       
       // 격자점 좌표 계산 (양이온 위치는 항상 고정, 여백 포함)
       const atoms = [];
       const currentGridSize = 5; // 연성과 전성 모드: 5x5 (처음으로와 동일)
       
       // 초기화면과 동일한 방식: 정확히 5x5=25개 원자, 캔버스 중심에 배치
       const spacing = densityCanvas.width / (currentGridSize + 1);
       const totalWidth = currentGridSize * spacing;
       const totalHeight = currentGridSize * spacing;
       const startX = (densityCanvas.width - totalWidth) / 2;
       const startY = (densityCanvas.height - totalHeight) / 2;
       
       // deformOffset: 0(원위치)~1(최대 이동)
       const slipRow = 2; // 0~4 중 2번째 줄(중앙)
       const slipAmount = deformOffset * spacing * 0.9; // 오른쪽으로 이동
       
       for (let i = 0; i < currentGridSize; i++) {
         for (let j = 0; j < currentGridSize; j++) {
           let x = startX + i * spacing + spacing/2;
           let y = startY + j * spacing + spacing/2;
           if (j === slipRow) x += slipAmount;
           atoms.push([x, y, j === slipRow]);
         }
       }
       
       // 전자밀도 그리기 (처음으로 모드와 동일한 방식)
       const imageData = densityCtx.createImageData(densityCanvas.width, densityCanvas.height);
       const densities = new Array(densityCanvas.width * densityCanvas.height);
       
       // 전자밀도 계산
       for (let y = 0; y < densityCanvas.height; y++) {
         for (let x = 0; x < densityCanvas.width; x++) {
           let d = 0;
           for (const [cx, cy] of atoms) {
             const dx = x - cx;
             const dy = y - cy;
             const sigma = radiusToSigma(element.radius);
             d += Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
           }
           densities[y * densityCanvas.width + x] = d;
         }
       }
       
       // 최대 밀도 찾기
       let maxDensity = 0;
       for (let i = 0; i < densities.length; i++) {
         const d = densities[i];
         if (d > maxDensity) maxDensity = d;
       }
       
       // 이미지 데이터 생성
       for (let y = 0; y < densityCanvas.height; y++) {
         for (let x = 0; x < densityCanvas.width; x++) {
           const d = densities[y * densityCanvas.width + x] / maxDensity;
           let r, g, b;
           
           // 원래 금속 색상 계열
           const base = element.color;
           const r0 = parseInt(base.slice(1,3),16);
           const g0 = parseInt(base.slice(3,5),16);
           const b0 = parseInt(base.slice(5,7),16);
           r = Math.round(r0 + d * (255 - r0));
           g = Math.round(g0 + d * (255 - g0));
           b = Math.round(b0 + d * (255 - b0));
           
           const a = 255;
           const idx = (y * densityCanvas.width + x) * 4;
           imageData.data[idx] = r;
           imageData.data[idx + 1] = g;
           imageData.data[idx + 2] = b;
           imageData.data[idx + 3] = a;
         }
       }
       ctx.putImageData(imageData, 0, 0); // 오프스크린 캔버스에 그리기
       
       // 금속 양이온 그리기 (연성과 전성 모드용 - 텍스트 없음)
       ctx.strokeStyle = "#fff";
       ctx.lineWidth = 2;
       ctx.font = "14px sans-serif";
       ctx.textAlign = "center";
       ctx.textBaseline = "top";
       ctx.fillStyle = "#fff";
       
       for (const [cx, cy, isSlip] of atoms) {
         const atomRadiusPx = radiusToPixel(element.radius);
         const ionRadiusPx = ionRadiusToPixel(element.ionRadius);
         
         // 원자 반지름 원
         ctx.save();
         ctx.globalAlpha = 0.5;
         ctx.beginPath();
         ctx.arc(cx, cy, atomRadiusPx, 0, 2 * Math.PI);
         ctx.strokeStyle = isSlip ? "#ffeb3b" : "#fff";
         ctx.lineWidth = isSlip ? 2.5 : 1.2;
         ctx.stroke();
         ctx.restore();
         
         // 금속양이온
         ctx.beginPath();
         ctx.arc(cx, cy, ionRadiusPx, 0, 2 * Math.PI);
         ctx.fillStyle = isSlip ? "#ffeb3b" : "#fff";
         ctx.globalAlpha = isSlip ? 0.95 : 0.85;
         ctx.fill();
         ctx.globalAlpha = 1.0;
         ctx.strokeStyle = "#888";
         ctx.lineWidth = 1;
         ctx.stroke();
       }
       
       // 설명 텍스트 제거 (연성과 전성 모드에서는 텍스트 없음)
       
       // 배경을 메인 캔버스에 복사
       densityCtx.clearRect(0, 0, densityCanvas.width, densityCanvas.height);
       densityCtx.drawImage(backgroundCanvas, 0, 0);
     }

    // 3. 변형 애니메이션
    function animateDuctility() {
      const target = deformActive ? 1 : 0;
      function step() {
        if (Math.abs(deformOffset - target) < 0.01) {
          deformOffset = target;
          cacheInvalid = true; // 캐시 무효화
          draw();
          
          // 애니메이션 완료 시 버튼 다시 활성화
          deformBtn.disabled = false;
          deformBtn.textContent = deformActive ? '변형 해제' : '변형 가하기';
          deformBtn.style.opacity = '1.0';
          deformBtn.style.cursor = 'pointer';
          
          return;
        }
        deformOffset += (target - deformOffset) * 0.18;
        cacheInvalid = true; // 캐시 무효화 (deformOffset 변경)
        draw();
        requestAnimationFrame(step);
      }
      step();
    }

    // 4. draw() 함수에 추가
    const oldDraw = draw;
    draw = function() {
      if (mode === 'ductility') {
        drawDuctility();
      } else if (mode === 'luster') {
        drawLuster();
      } else {
        oldDraw();
      }
    }

    // 5. updateDesc()에 설명 추가
    const oldUpdateDesc = updateDesc;
    updateDesc = function() {
      if (mode === 'ductility') {
        desc.innerHTML = `<b>금속의 연성과 전성</b><br>
        금속 양이온의 한 층이 미끄러지듯 이동해도<br>
        자유전자가 결합을 유지하여 구조가 끊어지지 않습니다.<br>
        <span style='color:#ffeb3b'>[변형 가하기] 버튼</span>을 눌러 층의 이동을 관찰해보세요.`;
        unitCellInfo.innerHTML = '';
      } else if (mode === 'luster') {
        desc.innerHTML = `<b>금속의 광택과 에너지 준위</b><br>
        금속은 자유전자가 대부분의 가시광선을 흡수하고 재방출하여<br>
        특유의 광택을 나타냅니다. 원자 수 증가에 따라<br>
        원자 오비탈이 에너지 밴드로 변화하는 과정을 관찰해보세요.`;
        leftTitle.textContent = '금속 결정 구조와 에너지 준위';

             } else if (mode === 'electric') {
         desc.innerHTML = `<b>금속의 전기전도성</b><br>
         자유전자가 전기장 방향으로 연속적으로 흐르며<br>
         화면 끝에서 사라진 전자는 왼쪽에서 새로운 전자로 나타납니다.<br>
         <span style='color:#ffeb3b'>[스위치]</span>를 켜서 전류 흐름을 관찰해보세요.`;
       } else if (mode === 'thermal') {
         desc.innerHTML = `<b>금속의 열전도성</b><br>
         열원에 접촉한 전자가 자유롭고 무작위하게 움직이며<br>
         고온의 전자와 충돌한 원자는 온도가 증가합니다.<br>
         <span style='color:#ffeb3b'>[열 가하기]</span> 버튼을 눌러 열 전달을 관찰해보세요.`;
      } else {
        oldUpdateDesc();
      }
    }

         // 6. resetAll()에 deform 변수 리셋
     const oldResetAll = resetAll;
     resetAll = function() {
       deformActive = false;
       deformOffset = 0;
       spectrumActive = false;
       isSolidState = false;
       oldResetAll();
     }

    // 7. 광택 모드 관련 함수들
    
    // 원자 수 증가에 따른 추가 방출선 생성
    function generateAdditionalLines(baseLine, atomCount) {
      const additionalLines = [];
      const baseWavelength = baseLine.wavelength;
      const baseColor = baseLine.color;
      
      // 원자 수에 따라 추가 선들 생성 (더 자연스러운 증가)
      const maxAdditionalLines = Math.min(atomCount - 1, 4); // 최대 4개 추가 선
      
      for (let i = 1; i <= maxAdditionalLines; i++) {
        // 기본 선 주변에 점진적으로 증가하는 파장 변화
        const wavelengthVariation = (Math.random() - 0.5) * (10 + i * 2); // ±(5+i)nm 변화
        const newWavelength = baseWavelength + wavelengthVariation;
        
        // 강도는 원자 수가 증가할수록 점진적으로 감소
        const intensity = baseLine.intensity * (0.9 - i * 0.2);
        
        // 색상도 약간의 변화 (더 일관성 있게)
        const colorVariation = Math.random() * 0.2;
        const newColor = adjustColorBrightness(baseColor, 1 - colorVariation);
        
        additionalLines.push({
          wavelength: newWavelength,
          intensity: Math.max(0.05, intensity),
          color: newColor
        });
      }
      
      return additionalLines;
    }
    
    // 색상 밝기 조정 함수
    function adjustColorBrightness(color, factor) {
      const rgb = hexToRgb(color);
      const r = Math.round(rgb.r * factor);
      const g = Math.round(rgb.g * factor);
      const b = Math.round(rgb.b * factor);
      return `rgb(${r},${g},${b})`;
    }
    
    function drawSpectrum() {
      const ctx = spectrumCanvas.getContext('2d');
      ctx.clearRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
      
      // 원자 개수에 따른 점진적 스펙트럼 변화
      if (atomCount <= 1) {
        drawLineSpectrum(ctx);
      } else if (atomCount <= 3) {
        drawLineSpectrum(ctx, 0.2); // 원자 2-3개: 기존 선에서 개수 증가
      } else if (atomCount <= 6) {
        drawTransitionSpectrum(ctx, (atomCount - 3) / 3); // 원자 4-6개: 선→연속 전환
      } else {
        drawContinuousSpectrum(ctx); // 원자 7개 이상: 완전한 연속 스펙트럼
      }
    }

    function drawLineSpectrum(ctx, continuity = 0) {
      const element = currentElement || elements[select.value];
      
      // 배경 그리기
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
      
      // 파장 축 그리기 (가시광선 범위: 380-750nm)
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const x = (i / 10) * spectrumCanvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, spectrumCanvas.height);
        ctx.stroke();
      }
      
      // 파장 라벨 (가시광선 범위)
      ctx.fillStyle = '#666';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      for (let i = 0; i <= 10; i++) {
        const x = (i / 10) * spectrumCanvas.width;
        const wavelength = 380 + (i / 10) * 370; // 380-750nm
        ctx.fillText(`${wavelength}nm`, x, spectrumCanvas.height - 5);
      }
      
      // 실제 원소별 방출선 그리기
      if (element.emissionLines) {
        element.emissionLines.forEach((line, index) => {
          // 가시광선 범위 내의 선만 표시
          if (line.wavelength >= 380 && line.wavelength <= 750) {
            const x = ((line.wavelength - 380) / 370) * spectrumCanvas.width;
            const intensity = line.intensity * (0.8 + Math.random() * 0.2);
            
            // 선 그리기
            ctx.strokeStyle = line.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, 20);
            ctx.lineTo(x, spectrumCanvas.height - 20);
            ctx.stroke();
            
            // 강도 표시
            ctx.fillStyle = line.color;
            ctx.globalAlpha = intensity;
            ctx.fillRect(x - 2, 20, 4, spectrumCanvas.height - 40);
            ctx.globalAlpha = 1.0;
            
            // 원자 수 증가에 따른 추가 선들
            if (atomCount > 1) {
              const additionalLines = generateAdditionalLines(line, atomCount);
              additionalLines.forEach(additionalLine => {
                if (additionalLine.wavelength >= 380 && additionalLine.wavelength <= 750) {
                  const ax = ((additionalLine.wavelength - 380) / 370) * spectrumCanvas.width;
                  const aIntensity = additionalLine.intensity * 0.6;
                  
                  ctx.strokeStyle = additionalLine.color;
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.moveTo(ax, 20);
                  ctx.lineTo(ax, spectrumCanvas.height - 20);
                  ctx.stroke();
                  
                  ctx.fillStyle = additionalLine.color;
                  ctx.globalAlpha = aIntensity;
                  ctx.fillRect(ax - 1, 20, 2, spectrumCanvas.height - 40);
                  ctx.globalAlpha = 1.0;
                }
              });
            }
            
            // 연속성 효과 추가 (원자 수가 증가할 때)
            if (continuity > 0) {
              const spread = 15 * continuity; // 연속성에 따른 확산
              const gradient = ctx.createLinearGradient(x - spread, 0, x + spread, 0);
              gradient.addColorStop(0, `rgba(255, 255, 255, 0)`);
              gradient.addColorStop(0.5, `rgba(${hexToRgb(line.color).r}, ${hexToRgb(line.color).g}, ${hexToRgb(line.color).b}, ${intensity * 0.3})`);
              gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
              
              ctx.fillStyle = gradient;
              ctx.fillRect(x - spread, 20, spread * 2, spectrumCanvas.height - 40);
            }
          }
        });
      }
    }

    function drawTransitionSpectrum(ctx, transitionRatio) {
      const element = currentElement || elements[select.value];
      
      // 배경 그리기
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
      
      // 파장 축 그리기 (가시광선 범위: 380-750nm)
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const x = (i / 10) * spectrumCanvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, spectrumCanvas.height);
        ctx.stroke();
      }
      
      // 파장 라벨 (가시광선 범위)
      ctx.fillStyle = '#666';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      for (let i = 0; i <= 10; i++) {
        const x = (i / 10) * spectrumCanvas.width;
        const wavelength = 380 + (i / 10) * 370; // 380-750nm
        ctx.fillText(`${wavelength}nm`, x, spectrumCanvas.height - 5);
      }
      
      // 기존 선 스펙트럼을 기반으로 점진적 전환
      if (element.emissionLines) {
        element.emissionLines.forEach((line, index) => {
          // 가시광선 범위 내의 선만 표시
          if (line.wavelength >= 380 && line.wavelength <= 750) {
            const x = ((line.wavelength - 380) / 370) * spectrumCanvas.width;
            const baseIntensity = line.intensity * (0.8 + Math.random() * 0.2);
            
            // 선 스펙트럼 부분 (점점 약해짐)
            const lineIntensity = baseIntensity * (1 - transitionRatio * 0.7);
            
            if (lineIntensity > 0.1) {
              ctx.strokeStyle = line.color;
              ctx.lineWidth = 3 * (1 - transitionRatio * 0.5);
              ctx.beginPath();
              ctx.moveTo(x, 20);
              ctx.lineTo(x, spectrumCanvas.height - 20);
              ctx.stroke();
              
              ctx.fillStyle = line.color;
              ctx.globalAlpha = lineIntensity;
              ctx.fillRect(x - 2, 20, 4, spectrumCanvas.height - 40);
              ctx.globalAlpha = 1.0;
            }
            
            // 원자 수 증가에 따른 추가 선들 (점점 약해짐)
            if (atomCount > 1) {
              const additionalLines = generateAdditionalLines(line, atomCount);
              additionalLines.forEach(additionalLine => {
                if (additionalLine.wavelength >= 380 && additionalLine.wavelength <= 750) {
                  const ax = ((additionalLine.wavelength - 380) / 370) * spectrumCanvas.width;
                  const aIntensity = additionalLine.intensity * 0.6 * (1 - transitionRatio * 0.8);
                  
                  if (aIntensity > 0.05) {
                    ctx.strokeStyle = additionalLine.color;
                    ctx.lineWidth = 2 * (1 - transitionRatio * 0.6);
                    ctx.beginPath();
                    ctx.moveTo(ax, 20);
                    ctx.lineTo(ax, spectrumCanvas.height - 20);
                    ctx.stroke();
                    
                    ctx.fillStyle = additionalLine.color;
                    ctx.globalAlpha = aIntensity;
                    ctx.fillRect(ax - 1, 20, 2, spectrumCanvas.height - 40);
                    ctx.globalAlpha = 1.0;
                  }
                }
              });
            }
          }
        });
      }
      
      // 연속 스펙트럼 부분 (점점 강해짐)
      const gradient = ctx.createLinearGradient(0, 0, spectrumCanvas.width, 0);
      
      for (let i = 0; i <= 100; i++) {
        const x = (i / 100) * spectrumCanvas.width;
        const wavelength = 380 + (i / 100) * 370; // 380-750nm
        const color = wavelengthToColor(wavelength);
        const intensity = (0.2 + Math.random() * 0.3) * transitionRatio; // 전환 비율에 따라 강도 증가
        
        gradient.addColorStop(i / 100, `rgba(${color.r}, ${color.g}, ${color.b}, ${intensity})`);
      }
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 20, spectrumCanvas.width, spectrumCanvas.height - 40);
    }

    function drawContinuousSpectrum(ctx) {
      const element = currentElement || elements[select.value];
      const baseColor = element.color;
      
      // 배경 그리기
      ctx.fillStyle = '#111';
      ctx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
      
      // 파장 축 그리기 (가시광선 범위: 380-750nm)
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const x = (i / 10) * spectrumCanvas.width;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, spectrumCanvas.height);
        ctx.stroke();
      }
      
      // 파장 라벨 (가시광선 범위)
      ctx.fillStyle = '#666';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      for (let i = 0; i <= 10; i++) {
        const x = (i / 10) * spectrumCanvas.width;
        const wavelength = 380 + (i / 10) * 370; // 380-750nm
        ctx.fillText(`${wavelength}nm`, x, spectrumCanvas.height - 5);
      }
      
      // 연속 스펙트럼 그리기 (고체 상태)
      const gradient = ctx.createLinearGradient(0, 0, spectrumCanvas.width, 0);
      
      // 가시광선 영역의 연속 스펙트럼
      for (let i = 0; i <= 100; i++) {
        const x = (i / 100) * spectrumCanvas.width;
        const wavelength = 380 + (i / 100) * 370; // 380-750nm
        const color = wavelengthToColor(wavelength);
        const intensity = 0.6 + Math.random() * 0.4; // 연속적인 강도 변화
        
        gradient.addColorStop(i / 100, `rgba(${color.r}, ${color.g}, ${color.b}, ${intensity})`);
      }
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 20, spectrumCanvas.width, spectrumCanvas.height - 40);
    }

    function getElementColors(element) {
      // 각 원소별 특성 색상 반환
      const colorMap = {
        'Na': ['#ff6b6b', '#ffd93d'], // 나트륨: 주황-노랑
        'Cu': ['#ff6b6b', '#ffd93d', '#4ecdc4'], // 구리: 주황-노랑-청록
        'Ag': ['#f8f9fa', '#e9ecef', '#dee2e6'], // 은: 흰색 계열
        'Au': ['#ffd700', '#ffed4e', '#fff200'], // 금: 금색 계열
        'Fe': ['#ff6b6b', '#ff8e8e'], // 철: 빨강 계열
        'Al': ['#4ecdc4', '#45b7aa'] // 알루미늄: 청록 계열
      };
      return colorMap[element.symbol] || ['#ffffff'];
    }

    function colorToWavelength(color) {
      // 색상을 대략적인 파장으로 변환
      const colorMap = {
        '#ff6b6b': 650, '#ffd93d': 580, '#4ecdc4': 500,
        '#f8f9fa': 550, '#e9ecef': 540, '#dee2e6': 530,
        '#ffd700': 570, '#ffed4e': 560, '#fff200': 550,
        '#ff8e8e': 620, '#45b7aa': 480
      };
      return colorMap[color] || 550;
    }

    function wavelengthToColor(wavelength) {
      // 파장을 RGB 색상으로 변환
      let r, g, b;
      
      if (wavelength >= 380 && wavelength < 440) {
        r = -(wavelength - 440) / (440 - 380);
        g = 0.0;
        b = 1.0;
      } else if (wavelength >= 440 && wavelength < 490) {
        r = 0.0;
        g = (wavelength - 440) / (490 - 440);
        b = 1.0;
      } else if (wavelength >= 490 && wavelength < 510) {
        r = 0.0;
        g = 1.0;
        b = -(wavelength - 510) / (510 - 490);
      } else if (wavelength >= 510 && wavelength < 580) {
        r = (wavelength - 510) / (580 - 510);
        g = 1.0;
        b = 0.0;
      } else if (wavelength >= 580 && wavelength < 645) {
        r = 1.0;
        g = -(wavelength - 645) / (645 - 580);
        b = 0.0;
      } else if (wavelength >= 645 && wavelength <= 780) {
        r = 1.0;
        g = 0.0;
        b = 0.0;
      } else {
        r = 0.0;
        g = 0.0;
        b = 0.0;
      }
      
      return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
      };
    }

    function updateSpectrumInfo() {
      const element = currentElement || elements[select.value];
      
      if (atomCount <= 1) {
        spectrumType.textContent = '원자 방출 스펙트럼';
        if (element.emissionLines) {
          const mainLine = element.emissionLines[0];
          spectrumInfo.textContent = `${element.name}의 주요 방출선: ${mainLine.wavelength}nm (${getWavelengthColor(mainLine.wavelength)})`;
        } else {
          spectrumInfo.textContent = '단일 원자 상태: 명확한 원자 오비탈 에너지 준위';
        }
      } else if (atomCount <= 3) {
        spectrumType.textContent = '선 스펙트럼 (확산)';
        spectrumInfo.textContent = '소수의 원자: 방출선이 약간 확산되며 추가 선들 생성';
      } else if (atomCount <= 6) {
        spectrumType.textContent = '전환 스펙트럼';
        spectrumInfo.textContent = '원자 간 상호작용: 선 스펙트럼 → 연속 스펙트럼 전환 과정';
      } else {
        spectrumType.textContent = '연속 스펙트럼';
        spectrumInfo.textContent = '고체 상태: 완전한 에너지 밴드 형성으로 연속적인 스펙트럼';
      }
    }
    
    // 파장을 색상 이름으로 변환
    function getWavelengthColor(wavelength) {
      if (wavelength < 450) return '보라색';
      if (wavelength < 485) return '청색';
      if (wavelength < 500) return '청녹색';
      if (wavelength < 565) return '녹색';
      if (wavelength < 590) return '노란색';
      if (wavelength < 625) return '주황색';
      return '빨간색';
    }

    function drawLuster() {
      const element = currentElement || elements[select.value];
      
      // 캐시 무효화 체크
      const needsRedraw = cacheInvalid || 
                         lastElement !== element || 
                         lastMode !== mode;
      
      if (!needsRedraw) {
        // 캐시된 배경을 메인 캔버스에 복사
        densityCtx.clearRect(0, 0, densityCanvas.width, densityCanvas.height);
        densityCtx.drawImage(backgroundCanvas, 0, 0);
        return;
      }
      
      // 캐시 무효화 플래그 업데이트
      cacheInvalid = false;
      lastElement = element;
      lastMode = mode;
      
      const ctx = backgroundCtx;
      ctx.clearRect(0, 0, densityCanvas.width, densityCanvas.height);
      
      // 원자 위치 계산 (기본 격자 + 사용자 추가 원자)
      const atoms = [];
      
      // 기본 격자 원자들 (사용자가 원자를 추가하지 않았을 때만 표시)
      if (customAtoms.length === 0) {
        const gridSize = 5; // 6x6에서 5x5로 변경
        const spacing = densityCanvas.width / (gridSize + 1);
        const totalWidth = gridSize * spacing;
        const totalHeight = gridSize * spacing;
        const startX = (densityCanvas.width - totalWidth) / 2;
        const startY = (densityCanvas.height - totalHeight) / 2;
        
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const x = startX + i * spacing + spacing/2;
            const y = startY + j * spacing + spacing/2;
            atoms.push([x, y]);
          }
        }
      } else {
        // 사용자가 추가한 원자들만 사용
        atoms.push(...customAtoms);
      }
      
      // 전자밀도 그리기 (광택 효과를 위해 더 밝게)
      const imageData = ctx.createImageData(densityCanvas.width, densityCanvas.height);
      
      for (let y = 0; y < densityCanvas.height; y++) {
        for (let x = 0; x < densityCanvas.width; x++) {
          let d = 0;
          for (const [cx, cy] of atoms) {
            const dx = x - cx;
            const dy = y - cy;
            const sigma = radiusToSigma(element.radius);
            d += Math.exp(-(dx * dx + dy * dy) / (2 * sigma * sigma));
          }
          
          // 광택 효과를 위한 밝기 조정
          d = Math.min(1.0, d * 1.5);
          
          const idx = (y * densityCanvas.width + x) * 4;
          const intensity = Math.round(d * 255);
          
          // 금속의 특성에 따른 색상 적용
          const color = hexToRgb(element.color);
          imageData.data[idx] = Math.round(color.r * d);     // R
          imageData.data[idx + 1] = Math.round(color.g * d); // G
          imageData.data[idx + 2] = Math.round(color.b * d); // B
          imageData.data[idx + 3] = 255;                     // A
        }
      }
      
      ctx.putImageData(imageData, 0, 0);
      
      // 원자핵 그리기 (광택 모드에서는 더 작게)
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 1;
      ctx.font = "12px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      
      for (const [cx, cy] of atoms) {
        const ionRadiusPx = ionRadiusToPixel(element.ionRadius) * 0.8;
        
        // 원자핵
        ctx.beginPath();
        ctx.arc(cx, cy, ionRadiusPx, 0, 2 * Math.PI);
        ctx.fillStyle = "#fff";
        ctx.globalAlpha = 0.9;
        ctx.fill();
        ctx.globalAlpha = 1.0;
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // 에너지 준위 그리기
        drawEnergyLevels(ctx, cx, cy, ionRadiusPx);
      }
      
      // 격자점 표시 (광택 모드에서만)
      if (mode === 'luster') {
        const gridPositions = calculateGridPositions();
        
        gridPositions.forEach(pos => {
          const isOccupied = customAtoms.some(atom => 
            Math.abs(atom[0] - pos[0]) < 5 && 
            Math.abs(atom[1] - pos[1]) < 5
          );
          
          if (!isOccupied) {
            // 빈 격자점 표시
            ctx.beginPath();
            ctx.arc(pos[0], pos[1], 3, 0, 2 * Math.PI);
            ctx.fillStyle = "#666";
            ctx.globalAlpha = 0.5;
            ctx.fill();
            ctx.globalAlpha = 1.0;
            ctx.strokeStyle = "#999";
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        });
      }
      
      // 배경을 메인 캔버스에 복사
      densityCtx.clearRect(0, 0, densityCanvas.width, densityCanvas.height);
      densityCtx.drawImage(backgroundCanvas, 0, 0);
    }

    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : {r: 255, g: 255, b: 255};
    }

    // 격자 위치 계산 함수
    function calculateGridPositions() {
      const gridSize = 5; // 5x5 격자로 변경
      const spacing = densityCanvas.width / (gridSize + 1);
      const totalWidth = gridSize * spacing;
      const totalHeight = gridSize * spacing;
      const startX = (densityCanvas.width - totalWidth) / 2;
      const startY = (densityCanvas.height - totalHeight) / 2;
      
      const gridPositions = [];
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const x = startX + i * spacing + spacing/2;
          const y = startY + j * spacing + spacing/2;
          gridPositions.push([x, y]);
        }
      }
      return gridPositions;
    }

    function findNearestGridPosition(x, y) {
      const gridPositions = calculateGridPositions();
      let nearestPos = null;
      let minDistance = Infinity;
      
      gridPositions.forEach(pos => {
        const dx = x - pos[0];
        const dy = y - pos[1];
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < minDistance && distance < 40) { // 40px 반경 내의 격자점만
          minDistance = distance;
          nearestPos = pos;
        }
      });
      
      return nearestPos;
    }

    // 원자 추가/제거 함수들
    function addAtom(x, y) {
      const nearestGridPos = findNearestGridPosition(x, y);
      
      if (nearestGridPos) {
        // 이미 해당 격자 위치에 원자가 있는지 확인
        const isOccupied = customAtoms.some(atom => 
          Math.abs(atom[0] - nearestGridPos[0]) < 5 && 
          Math.abs(atom[1] - nearestGridPos[1]) < 5
        );
        
        if (!isOccupied) {
          customAtoms.push(nearestGridPos);
          atomCount = customAtoms.length;
          updateAtomCountDisplay();
          cacheInvalid = true;
          draw();
          updateSpectrumBasedOnAtomCount();
        }
      }
    }

    function removeAtom(x, y) {
      // 클릭한 위치에서 가장 가까운 원자 찾기
      let closestIndex = -1;
      let minDistance = Infinity;
      
      customAtoms.forEach((atom, index) => {
        const dx = x - atom[0];
        const dy = y - atom[1];
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < minDistance && distance < 30) { // 30px 반경 내
          minDistance = distance;
          closestIndex = index;
        }
      });
      
      if (closestIndex !== -1) {
        customAtoms.splice(closestIndex, 1);
        atomCount = customAtoms.length;
        updateAtomCountDisplay();
        cacheInvalid = true;
        draw();
        updateSpectrumBasedOnAtomCount();
      }
    }

    function updateAtomCountDisplay() {
      atomCountDisplay.textContent = `원자 개수: ${atomCount}개`;
    }

    function updateAtomControls() {
      if (isAddingMode) {
        densityCanvas.style.cursor = 'crosshair';
      } else {
        densityCanvas.style.cursor = 'pointer';
      }
    }

    function updateSpectrumBasedOnAtomCount() {
      // 원자 개수에 따라 스펙트럼 타입 결정
      if (atomCount <= 1) {
        isSolidState = false; // 선 스펙트럼
      } else if (atomCount <= 5) {
        isSolidState = false; // 선 스펙트럼에서 연속 스펙트럼으로 점진적 전환
      } else if (atomCount <= 10) {
        isSolidState = false; // 연속 스펙트럼으로 전환 중
      } else {
        isSolidState = true; // 완전한 연속 스펙트럼
      }
      
      drawSpectrum();
      updateSpectrumInfo();
    }

    // 에너지 준위 그리기 함수들
    function drawEnergyLevels(ctx, x, y, ionRadius) {
      if (atomCount <= 1) {
        drawAtomicOrbitals(ctx, x, y, ionRadius);
      } else if (atomCount <= 5) {
        // 1~5개: 점진적 전환 (0.0 ~ 0.8)
        const transitionRatio = (atomCount - 1) / 5;
        drawTransitionLevels(ctx, x, y, ionRadius, transitionRatio);
      } else if (atomCount <= 10) {
        // 6~10개: 밴드 형성 (0.8 ~ 1.0)
        const transitionRatio = 0.8 + (atomCount - 5) / 25;
        drawTransitionLevels(ctx, x, y, ionRadius, transitionRatio);
      } else {
        drawEnergyBands(ctx, x, y, ionRadius);
      }
    }

    function drawAtomicOrbitals(ctx, x, y, ionRadius) {
      // 원자 오비탈 (명확한 에너지 준위)
      const orbitalLevels = [1, 2, 3]; // 3개의 에너지 준위
      
      orbitalLevels.forEach((level, index) => {
        const radius = ionRadius + level * 15;
        
        // 에너지 준위 원 (흰색으로 통일)
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.8;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
        
        // 에너지 레벨 표시 (흰색으로 통일)
        ctx.fillStyle = "#ffffff";
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`E${level}`, x + radius + 8, y);
      });
    }

    function drawTransitionLevels(ctx, x, y, ionRadius, transitionRatio) {
      // 전환 단계 (원자 오비탈 → 에너지 밴드)
      const baseLevels = [1, 2, 3];
      
      baseLevels.forEach((level, index) => {
        const baseRadius = ionRadius + level * 15;
        // 더 점진적인 밴드 폭 계산
        const maxBandWidth = 15; // 최대 밴드 폭 증가
        const bandWidth = maxBandWidth * Math.pow(transitionRatio, 1.5); // 비선형 증가로 더 부드러운 전환
        
        // 기본 에너지 준위 (점점 흐려짐, 흰색으로 통일)
        ctx.beginPath();
        ctx.arc(x, y, baseRadius, 0, 2 * Math.PI);
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.8 * (1 - transitionRatio * 0.7); // 더 천천히 흐려짐
        ctx.stroke();
        ctx.globalAlpha = 1.0;
        
        // 밴드 영역 (점점 두꺼워짐, 흰색으로 통일)
        if (bandWidth > 0.5) {
          ctx.beginPath();
          ctx.arc(x, y, baseRadius, 0, 2 * Math.PI);
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = bandWidth;
          ctx.globalAlpha = 0.4 * Math.pow(transitionRatio, 0.8); // 더 부드러운 투명도 변화
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        }
        
        // 에너지 레벨 표시 (흰색으로 통일)
        ctx.fillStyle = "#ffffff";
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`E${level}`, x + baseRadius + 8, y);
      });
    }

    function drawEnergyBands(ctx, x, y, ionRadius) {
      // 에너지 밴드 (연속적인 에너지 준위)
      const bandLevels = [1, 2, 3];
      
      bandLevels.forEach((level, index) => {
        const baseRadius = ionRadius + level * 15;
        const bandWidth = 12; // 완전한 밴드 폭
        
        // 밴드 영역 (두꺼운 원, 흰색으로 통일)
        ctx.beginPath();
        ctx.arc(x, y, baseRadius, 0, 2 * Math.PI);
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = bandWidth;
        ctx.globalAlpha = 0.4;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
        
        // 밴드 내부의 세밀한 구조 (흰색으로 통일)
        for (let i = 0; i < 3; i++) {
          const subRadius = baseRadius - bandWidth/2 + i * bandWidth/2;
          ctx.beginPath();
          ctx.arc(x, y, subRadius, 0, 2 * Math.PI);
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 1;
          ctx.globalAlpha = 0.6;
          ctx.stroke();
          ctx.globalAlpha = 1.0;
        }
        
        // 에너지 밴드 표시 (흰색으로 통일)
        ctx.fillStyle = "#ffffff";
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`Band${level}`, x + baseRadius + 8, y);
      });
    }

    // 버튼 비활성화 함수
    function disableOtherModeButtons(activeButton) {
      const modeButtons = [modeElectric, modeThermal, modeDuctility, modeLuster];
      modeButtons.forEach(button => {
        if (button !== activeButton) {
          button.classList.add('disabled');
        } else {
          button.classList.remove('disabled');
        }
      });
    }

    // 버튼 활성화 함수 (처음으로 모드용)
    function enableAllModeButtons() {
      const modeButtons = [modeElectric, modeThermal, modeDuctility, modeLuster];
      modeButtons.forEach(button => {
        button.classList.remove('disabled');
      });
    }

    // 열원 근처의 두 원자를 고온 상태로 설정
    const heaterAtoms = [0, 1]; // 첫 번째, 두 번째 원자
    heaterAtoms.forEach(index => {
      atomTemperatures.set(index, 200); // 고온 설정
    });

    function transferHeat(from, to, amount) {
      from.temperature -= amount;
      to.temperature += amount;
      // 온도 범위 제한
      from.temperature = Math.max(10, Math.min(200, from.temperature));
      to.temperature = Math.max(10, Math.min(200, to.temperature));
    }

    // 버튼 활성화 함수 (처음으로 모드용)
    function enableAllModeButtons() {
      const modeButtons = [modeElectric, modeThermal, modeDuctility, modeLuster];
      modeButtons.forEach(button => {
        button.classList.remove('disabled');
      });
    }
    
    // 열원 근처 원자 확인 함수
    function isHeaterAtom(atomIndex) {
      if (!hotSourceContact || !hotSourceVisible) return false;
      
      const atoms = [];
      const element = currentElement || elements[select.value];
      const spacing = densityCanvas.width / 7;
      const margin = spacing / 2;
      
      // 원자 위치 계산
      for (let i = 0; i <= Math.floor(densityCanvas.width / spacing); i++) {
        for (let j = 0; j <= Math.floor(densityCanvas.height / spacing); j++) {
          const x = i * spacing + margin;
          const y = j * spacing + margin;
          if (x < densityCanvas.width && y < densityCanvas.height) {
            atoms.push([x, y]);
          }
        }
      }
      
      if (atomIndex >= atoms.length) return false;
      
      const [cx, cy] = atoms[atomIndex];
      
      // 열원 근처의 원자인지 확인
      const leftColumnX = margin; // 맨 왼쪽 열의 x 좌표
      
      return Math.abs(cx - leftColumnX) < 10; // 맨 왼쪽 열에 있는 원자들
    }
  </script>
</body>
</html> 
